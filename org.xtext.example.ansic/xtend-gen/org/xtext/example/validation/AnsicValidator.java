/**
 * generated by Xtext 2.9.1
 */
package org.xtext.example.validation;

import com.google.common.base.Objects;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.xtext.example.ansic.AnsicPackage;
import org.xtext.example.ansic.DomainModel;
import org.xtext.example.ansic.PostFixEmpryParams;
import org.xtext.example.ansic.additive_expression;
import org.xtext.example.ansic.additive_expression_complement;
import org.xtext.example.ansic.additive_expression_linha;
import org.xtext.example.ansic.and_expression;
import org.xtext.example.ansic.and_expression_linha;
import org.xtext.example.ansic.argument_expression_list;
import org.xtext.example.ansic.assignment_expression;
import org.xtext.example.ansic.block_item;
import org.xtext.example.ansic.block_item_list;
import org.xtext.example.ansic.block_item_list_linha;
import org.xtext.example.ansic.cast_expression;
import org.xtext.example.ansic.compound_statement;
import org.xtext.example.ansic.conditional_expression;
import org.xtext.example.ansic.conditional_expression_linha;
import org.xtext.example.ansic.constant;
import org.xtext.example.ansic.declaration;
import org.xtext.example.ansic.declaration_specifiers;
import org.xtext.example.ansic.declarator;
import org.xtext.example.ansic.direct_declarator;
import org.xtext.example.ansic.direct_declarator_complemento;
import org.xtext.example.ansic.direct_declarator_linha;
import org.xtext.example.ansic.enum_specifier;
import org.xtext.example.ansic.equality_expression;
import org.xtext.example.ansic.equality_expression_linha;
import org.xtext.example.ansic.exclusive_or_expression;
import org.xtext.example.ansic.exclusive_or_expression_linha;
import org.xtext.example.ansic.expression;
import org.xtext.example.ansic.function_definition;
import org.xtext.example.ansic.inclusive_or_expression;
import org.xtext.example.ansic.inclusive_or_expression_linha;
import org.xtext.example.ansic.init_declarator;
import org.xtext.example.ansic.init_declarator_list;
import org.xtext.example.ansic.initializer;
import org.xtext.example.ansic.jump_statement;
import org.xtext.example.ansic.logical_and_expression;
import org.xtext.example.ansic.logical_and_expression_linha;
import org.xtext.example.ansic.logical_or_expression;
import org.xtext.example.ansic.logical_or_expression_linha;
import org.xtext.example.ansic.multiplicative_expression;
import org.xtext.example.ansic.multiplicative_expression_complement;
import org.xtext.example.ansic.multiplicative_expression_linha;
import org.xtext.example.ansic.parameter_declaration;
import org.xtext.example.ansic.parameter_lista;
import org.xtext.example.ansic.parameter_type_list;
import org.xtext.example.ansic.postfix_expression;
import org.xtext.example.ansic.postfix_expression_complement;
import org.xtext.example.ansic.primary_expression;
import org.xtext.example.ansic.relational_expression;
import org.xtext.example.ansic.relational_expression_linha;
import org.xtext.example.ansic.selection_statement;
import org.xtext.example.ansic.shift_expression;
import org.xtext.example.ansic.shift_expression_complement;
import org.xtext.example.ansic.shift_expression_linha;
import org.xtext.example.ansic.statement;
import org.xtext.example.ansic.type_specifier;
import org.xtext.example.ansic.unary_expression;
import org.xtext.example.validation.AbstractAnsicValidator;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class AnsicValidator extends AbstractAnsicValidator {
  public enum ExpRetType {
    NUMERIC,
    
    CHAR,
    
    BOOL;
  }
  
  public static class Function {
    public int param_number = 0;
    
    public List<String> params_types = new ArrayList<String>();
    
    public String retType;
    
    public String name;
  }
  
  public final static String INVALID_NAME = "invalidName";
  
  private HashMap<String, String> variables = CollectionLiterals.<String, String>newHashMap();
  
  private HashMap<String, AnsicValidator.Function> functions = CollectionLiterals.<String, AnsicValidator.Function>newHashMap();
  
  @Check
  public void restart(final DomainModel d) {
    InputOutput.<String>println("Clearing...");
    this.variables.clear();
    this.functions.clear();
  }
  
  public void checkDeclarationWithConstant(final String leftType, final primary_expression rightType) {
    boolean _and = false;
    boolean _and_1 = false;
    constant _constant = rightType.getConstant();
    String _f_constant = _constant.getF_constant();
    boolean _equals = Objects.equal(_f_constant, null);
    if (!_equals) {
      _and_1 = false;
    } else {
      constant _constant_1 = rightType.getConstant();
      String _enumz = _constant_1.getEnumz();
      boolean _equals_1 = Objects.equal(_enumz, null);
      _and_1 = _equals_1;
    }
    if (!_and_1) {
      _and = false;
    } else {
      constant _constant_2 = rightType.getConstant();
      String _char = _constant_2.getChar();
      boolean _equals_2 = Objects.equal(_char, null);
      _and = _equals_2;
    }
    if (_and) {
      boolean _or = false;
      boolean _or_1 = false;
      boolean _equals_3 = Objects.equal(leftType, "char");
      if (_equals_3) {
        _or_1 = true;
      } else {
        boolean _equals_4 = Objects.equal(leftType, "bool");
        _or_1 = _equals_4;
      }
      if (_or_1) {
        _or = true;
      } else {
        boolean _equals_5 = Objects.equal(leftType, "void");
        _or = _equals_5;
      }
      if (_or) {
        this.error("Esse tipo não recebe valores numéricos", 
          AnsicPackage.Literals.DECLARATION__DECLARATION_SPECIFIERS);
      }
    } else {
      constant _constant_3 = rightType.getConstant();
      String _f_constant_1 = _constant_3.getF_constant();
      boolean _notEquals = (!Objects.equal(_f_constant_1, null));
      if (_notEquals) {
        boolean _or_2 = false;
        boolean _or_3 = false;
        boolean _or_4 = false;
        boolean _equals_6 = Objects.equal(leftType, "char");
        if (_equals_6) {
          _or_4 = true;
        } else {
          boolean _equals_7 = Objects.equal(leftType, "bool");
          _or_4 = _equals_7;
        }
        if (_or_4) {
          _or_3 = true;
        } else {
          boolean _equals_8 = Objects.equal(leftType, "void");
          _or_3 = _equals_8;
        }
        if (_or_3) {
          _or_2 = true;
        } else {
          boolean _equals_9 = Objects.equal(leftType, "int");
          _or_2 = _equals_9;
        }
        if (_or_2) {
          this.error("Esse tipo não recebe valores numéricos com ponto flutuante", 
            AnsicPackage.Literals.DECLARATION__INIT_DECLARATOR_LIST);
        }
      }
    }
  }
  
  @Check
  public void validateFunctionReturn(final jump_statement ret) {
    expression _expression = ret.getExpression();
    boolean _notEquals = (!Objects.equal(_expression, null));
    if (_notEquals) {
      EObject current = ret.eContainer();
      while (((!Objects.equal(current, null)) && (!(current instanceof function_definition)))) {
        EObject _eContainer = current.eContainer();
        current = _eContainer;
      }
      if ((current instanceof function_definition)) {
        function_definition func = ((function_definition) current);
        EList<declaration_specifiers> _declaration_specifiers = func.getDeclaration_specifiers();
        declaration_specifiers _get = _declaration_specifiers.get(0);
        type_specifier _type_specifier = _get.getType_specifier();
        String argType = _type_specifier.getType_name_str();
        boolean _notEquals_1 = (!Objects.equal(argType, "void"));
        if (_notEquals_1) {
          expression _expression_1 = ret.getExpression();
          assignment_expression arg = _expression_1.getAssignment_expression();
          AnsicValidator.ExpRetType _expType = this.getExpType(arg);
          boolean _notEquals_2 = (!Objects.equal(_expType, null));
          if (_notEquals_2) {
            AnsicValidator.ExpRetType expRet = this.getExpType(arg);
            boolean _equals = Objects.equal(expRet, AnsicValidator.ExpRetType.NUMERIC);
            if (_equals) {
              boolean _equals_1 = Objects.equal(argType, "bool");
              if (_equals_1) {
                this.error("Tipo de parametro não compativel", 
                  null);
              }
            } else {
              boolean _equals_2 = Objects.equal(expRet, AnsicValidator.ExpRetType.BOOL);
              if (_equals_2) {
                boolean _notEquals_3 = (!Objects.equal(argType, "bool"));
                if (_notEquals_3) {
                  this.error("Tipo de parametro não compativel", 
                    null);
                }
              }
            }
          } else {
            InputOutput.<String>println("Is an contant or id");
            primary_expression idOrCons = this.primaryExpFromAssigExp(arg);
            boolean _and = false;
            String _identifier = idOrCons.getIdentifier();
            boolean _notEquals_4 = (!Objects.equal(_identifier, null));
            if (!_notEquals_4) {
              _and = false;
            } else {
              String _identifier_1 = idOrCons.getIdentifier();
              String _trim = _identifier_1.trim();
              boolean _isEmpty = _trim.isEmpty();
              boolean _not = (!_isEmpty);
              _and = _not;
            }
            if (_and) {
              String _identifier_2 = idOrCons.getIdentifier();
              boolean _containsKey = this.variables.containsKey(_identifier_2);
              if (_containsKey) {
                String _identifier_3 = idOrCons.getIdentifier();
                String _get_1 = this.variables.get(_identifier_3);
                boolean _notEquals_5 = (!Objects.equal(_get_1, argType));
                if (_notEquals_5) {
                  this.error("Retorno não compatível", 
                    null);
                }
              } else {
                String _identifier_4 = idOrCons.getIdentifier();
                boolean _containsKey_1 = this.functions.containsKey(_identifier_4);
                if (_containsKey_1) {
                  String _identifier_5 = idOrCons.getIdentifier();
                  AnsicValidator.Function _get_2 = this.functions.get(_identifier_5);
                  boolean _notEquals_6 = (!Objects.equal(_get_2.retType, argType));
                  if (_notEquals_6) {
                    this.error("Retorno não compatíve", 
                      null);
                  }
                }
              }
            }
            boolean _and_1 = false;
            boolean _and_2 = false;
            constant _constant = idOrCons.getConstant();
            boolean _notEquals_7 = (!Objects.equal(_constant, null));
            if (!_notEquals_7) {
              _and_2 = false;
            } else {
              constant _constant_1 = idOrCons.getConstant();
              String _char = _constant_1.getChar();
              boolean _notEquals_8 = (!Objects.equal(_char, null));
              _and_2 = _notEquals_8;
            }
            if (!_and_2) {
              _and_1 = false;
            } else {
              boolean _notEquals_9 = (!Objects.equal(argType, "char"));
              _and_1 = _notEquals_9;
            }
            if (_and_1) {
              this.error("Retorno não compatíve", 
                null);
            }
          }
        }
      }
    }
  }
  
  @Check
  public void checkForEmptyParamFunc(final PostFixEmpryParams call) {
    EObject _eContainer = call.eContainer();
    EObject _eContainer_1 = _eContainer.eContainer();
    postfix_expression parent = ((postfix_expression) _eContainer_1);
    primary_expression _primary_expression = parent.getPrimary_expression();
    String name = _primary_expression.getIdentifier();
    boolean _containsKey = this.functions.containsKey(name);
    boolean _not = (!_containsKey);
    if (_not) {
      this.error("Função não definida", 
        null);
    } else {
      AnsicValidator.Function func = this.functions.get(name);
      if ((func.param_number != 0)) {
        this.error("Numero de parametros incompativeis", 
          null);
      }
    }
  }
  
  public primary_expression primaryExpFromAssigExp(final assignment_expression exp) {
    conditional_expression _conditional_expression = exp.getConditional_expression();
    logical_or_expression _logical_or_expression = _conditional_expression.getLogical_or_expression();
    logical_and_expression _logical_and_expression = _logical_or_expression.getLogical_and_expression();
    inclusive_or_expression _inclusive_or_expression = _logical_and_expression.getInclusive_or_expression();
    exclusive_or_expression _exclusive_or_expression = _inclusive_or_expression.getExclusive_or_expression();
    and_expression _and_expression = _exclusive_or_expression.getAnd_expression();
    equality_expression _equality_expression = _and_expression.getEquality_expression();
    relational_expression _relational_expression = _equality_expression.getRelational_expression();
    shift_expression _shift_expression = _relational_expression.getShift_expression();
    additive_expression _additive_expression = _shift_expression.getAdditive_expression();
    multiplicative_expression _multiplicative_expression = _additive_expression.getMultiplicative_expression();
    cast_expression _cast_expression = _multiplicative_expression.getCast_expression();
    unary_expression _unary_expression = _cast_expression.getUnary_expression();
    postfix_expression _postfix_expression = _unary_expression.getPostfix_expression();
    primary_expression ret = _postfix_expression.getPrimary_expression();
    return ret;
  }
  
  public Object t() {
    if (true) {
      return Integer.valueOf(3);
    } else {
      return "oia";
    }
  }
  
  public AnsicValidator.ExpRetType getExpType(final assignment_expression exp) {
    conditional_expression current = exp.getConditional_expression();
    conditional_expression_linha _conditional_expression_linha = current.getConditional_expression_linha();
    boolean _notEquals = (!Objects.equal(_conditional_expression_linha, null));
    if (_notEquals) {
      return AnsicValidator.ExpRetType.BOOL;
    }
    logical_or_expression current2 = current.getLogical_or_expression();
    logical_or_expression_linha _logical_or_expression_linha = current2.getLogical_or_expression_linha();
    boolean _notEquals_1 = (!Objects.equal(_logical_or_expression_linha, null));
    if (_notEquals_1) {
      return AnsicValidator.ExpRetType.BOOL;
    }
    logical_and_expression current3 = current2.getLogical_and_expression();
    logical_and_expression_linha _logical_and_expression_linha = current3.getLogical_and_expression_linha();
    boolean _notEquals_2 = (!Objects.equal(_logical_and_expression_linha, null));
    if (_notEquals_2) {
      return AnsicValidator.ExpRetType.BOOL;
    }
    inclusive_or_expression current4 = current3.getInclusive_or_expression();
    inclusive_or_expression_linha _inclusive_or_expression_linha = current4.getInclusive_or_expression_linha();
    boolean _notEquals_3 = (!Objects.equal(_inclusive_or_expression_linha, null));
    if (_notEquals_3) {
      return AnsicValidator.ExpRetType.BOOL;
    }
    exclusive_or_expression current5 = current4.getExclusive_or_expression();
    exclusive_or_expression_linha _exclusive_or_expression_linha = current5.getExclusive_or_expression_linha();
    boolean _notEquals_4 = (!Objects.equal(_exclusive_or_expression_linha, null));
    if (_notEquals_4) {
      return AnsicValidator.ExpRetType.BOOL;
    }
    and_expression current6 = current5.getAnd_expression();
    and_expression_linha _and_expression_linha = current6.getAnd_expression_linha();
    boolean _notEquals_5 = (!Objects.equal(_and_expression_linha, null));
    if (_notEquals_5) {
      return AnsicValidator.ExpRetType.BOOL;
    }
    equality_expression current7 = current6.getEquality_expression();
    equality_expression_linha _equality_expression_linha = current7.getEquality_expression_linha();
    boolean _notEquals_6 = (!Objects.equal(_equality_expression_linha, null));
    if (_notEquals_6) {
      return AnsicValidator.ExpRetType.BOOL;
    }
    relational_expression current8 = current7.getRelational_expression();
    relational_expression_linha _relational_expression_linha = current8.getRelational_expression_linha();
    boolean _notEquals_7 = (!Objects.equal(_relational_expression_linha, null));
    if (_notEquals_7) {
      return AnsicValidator.ExpRetType.BOOL;
    }
    shift_expression current9 = current8.getShift_expression();
    shift_expression_linha _shift_expression_linha = current9.getShift_expression_linha();
    boolean _notEquals_8 = (!Objects.equal(_shift_expression_linha, null));
    if (_notEquals_8) {
      return AnsicValidator.ExpRetType.NUMERIC;
    }
    additive_expression current10 = current9.getAdditive_expression();
    additive_expression_linha _additive_expression_linha = current10.getAdditive_expression_linha();
    boolean _notEquals_9 = (!Objects.equal(_additive_expression_linha, null));
    if (_notEquals_9) {
      return AnsicValidator.ExpRetType.NUMERIC;
    }
    multiplicative_expression curent11 = current10.getMultiplicative_expression();
    multiplicative_expression_linha _multiplicative_expression_linha = curent11.getMultiplicative_expression_linha();
    boolean _notEquals_10 = (!Objects.equal(_multiplicative_expression_linha, null));
    if (_notEquals_10) {
      return AnsicValidator.ExpRetType.NUMERIC;
    }
    return null;
  }
  
  @Check
  public void checkBlockItemList(final block_item_list item) {
    EList<block_item_list_linha> _block_item_list_linha = item.getBlock_item_list_linha();
    boolean _isEmpty = _block_item_list_linha.isEmpty();
    if (_isEmpty) {
      EObject current = item.eContainer();
      while (((!Objects.equal(current, null)) && (!(current instanceof function_definition)))) {
        EObject _eContainer = current.eContainer();
        current = _eContainer;
      }
      if ((current instanceof function_definition)) {
        InputOutput.<String>println("Achou funcao2...");
        function_definition func = ((function_definition) current);
        EList<declaration_specifiers> _declaration_specifiers = func.getDeclaration_specifiers();
        declaration_specifiers _get = _declaration_specifiers.get(0);
        type_specifier _type_specifier = _get.getType_specifier();
        String retType = _type_specifier.getType_name_str();
        boolean _notEquals = (!Objects.equal(retType, "void"));
        if (_notEquals) {
          boolean _or = false;
          boolean _or_1 = false;
          block_item _block_item = item.getBlock_item();
          statement _statement = _block_item.getStatement();
          boolean _equals = Objects.equal(_statement, null);
          if (_equals) {
            _or_1 = true;
          } else {
            block_item _block_item_1 = item.getBlock_item();
            statement _statement_1 = _block_item_1.getStatement();
            jump_statement _jump_statement = _statement_1.getJump_statement();
            boolean _equals_1 = Objects.equal(_jump_statement, null);
            _or_1 = _equals_1;
          }
          if (_or_1) {
            _or = true;
          } else {
            block_item _block_item_2 = item.getBlock_item();
            statement _statement_2 = _block_item_2.getStatement();
            jump_statement _jump_statement_1 = _statement_2.getJump_statement();
            expression _expression = _jump_statement_1.getExpression();
            boolean _equals_2 = Objects.equal(_expression, null);
            _or = _equals_2;
          }
          if (_or) {
            this.error("Falta o return", null);
          }
        }
      }
    }
  }
  
  @Check
  public void checkBlockItemListLinha(final block_item_list_linha item) {
    InputOutput.<String>println("Sem instancia...");
    EList<block_item_list_linha> _block_item_list_linha = item.getBlock_item_list_linha();
    boolean _isEmpty = _block_item_list_linha.isEmpty();
    if (_isEmpty) {
      InputOutput.<String>println("Iniciando checagem...");
      EObject current = item.eContainer();
      while (((!Objects.equal(current, null)) && (!(current instanceof function_definition)))) {
        EObject _eContainer = current.eContainer();
        current = _eContainer;
      }
      InputOutput.<String>println("Achou funcao...");
      if ((current instanceof function_definition)) {
        InputOutput.<String>println("Achou funcao2...");
        function_definition func = ((function_definition) current);
        EList<declaration_specifiers> _declaration_specifiers = func.getDeclaration_specifiers();
        declaration_specifiers _get = _declaration_specifiers.get(0);
        type_specifier _type_specifier = _get.getType_specifier();
        String retType = _type_specifier.getType_name_str();
        boolean _notEquals = (!Objects.equal(retType, "void"));
        if (_notEquals) {
          boolean _or = false;
          boolean _or_1 = false;
          block_item _block_item = item.getBlock_item();
          statement _statement = _block_item.getStatement();
          boolean _equals = Objects.equal(_statement, null);
          if (_equals) {
            _or_1 = true;
          } else {
            block_item _block_item_1 = item.getBlock_item();
            statement _statement_1 = _block_item_1.getStatement();
            jump_statement _jump_statement = _statement_1.getJump_statement();
            boolean _equals_1 = Objects.equal(_jump_statement, null);
            _or_1 = _equals_1;
          }
          if (_or_1) {
            _or = true;
          } else {
            block_item _block_item_2 = item.getBlock_item();
            statement _statement_2 = _block_item_2.getStatement();
            jump_statement _jump_statement_1 = _statement_2.getJump_statement();
            expression _expression = _jump_statement_1.getExpression();
            boolean _equals_2 = Objects.equal(_expression, null);
            _or = _equals_2;
          }
          if (_or) {
            this.error("Falta o return", null);
          }
        }
      }
    }
  }
  
  public AnsicValidator.ExpRetType evaluateExp(final primary_expression primatyExp) {
    expression _expression = primatyExp.getExpression();
    boolean _equals = Objects.equal(_expression, null);
    if (_equals) {
      boolean _and = false;
      String _identifier = primatyExp.getIdentifier();
      boolean _notEquals = (!Objects.equal(_identifier, null));
      if (!_notEquals) {
        _and = false;
      } else {
        String _identifier_1 = primatyExp.getIdentifier();
        String _trim = _identifier_1.trim();
        boolean _isEmpty = _trim.isEmpty();
        boolean _not = (!_isEmpty);
        _and = _not;
      }
      if (_and) {
        String _identifier_2 = primatyExp.getIdentifier();
        boolean _containsKey = this.variables.containsKey(_identifier_2);
        boolean _not_1 = (!_containsKey);
        if (_not_1) {
          this.error("Variavel não declarada", null);
          return AnsicValidator.ExpRetType.NUMERIC;
        }
        String _identifier_3 = primatyExp.getIdentifier();
        String varType = this.variables.get(_identifier_3);
        boolean _equals_1 = varType.equals("char");
        if (_equals_1) {
          return AnsicValidator.ExpRetType.CHAR;
        } else {
          return AnsicValidator.ExpRetType.NUMERIC;
        }
      }
      boolean _and_1 = false;
      constant _constant = primatyExp.getConstant();
      String _char = _constant.getChar();
      boolean _notEquals_1 = (!Objects.equal(_char, null));
      if (!_notEquals_1) {
        _and_1 = false;
      } else {
        constant _constant_1 = primatyExp.getConstant();
        String _char_1 = _constant_1.getChar();
        String _trim_1 = _char_1.trim();
        boolean _isEmpty_1 = _trim_1.isEmpty();
        boolean _not_2 = (!_isEmpty_1);
        _and_1 = _not_2;
      }
      if (_and_1) {
        return AnsicValidator.ExpRetType.CHAR;
      }
      return AnsicValidator.ExpRetType.NUMERIC;
    } else {
      expression _expression_1 = primatyExp.getExpression();
      assignment_expression _assignment_expression = _expression_1.getAssignment_expression();
      return this.getExpType(_assignment_expression);
    }
  }
  
  @Check
  public void CheckAndExpExp(final and_expression andExp) {
    and_expression_linha _and_expression_linha = andExp.getAnd_expression_linha();
    boolean _notEquals = (!Objects.equal(_and_expression_linha, null));
    if (_notEquals) {
      equality_expression _equality_expression = andExp.getEquality_expression();
      relational_expression _relational_expression = _equality_expression.getRelational_expression();
      shift_expression _shift_expression = _relational_expression.getShift_expression();
      additive_expression _additive_expression = _shift_expression.getAdditive_expression();
      multiplicative_expression _multiplicative_expression = _additive_expression.getMultiplicative_expression();
      cast_expression _cast_expression = _multiplicative_expression.getCast_expression();
      unary_expression _unary_expression = _cast_expression.getUnary_expression();
      postfix_expression _postfix_expression = _unary_expression.getPostfix_expression();
      primary_expression currentExp = _postfix_expression.getPrimary_expression();
      AnsicValidator.ExpRetType lType = this.evaluateExp(currentExp);
      boolean _notEquals_1 = (!Objects.equal(lType, AnsicValidator.ExpRetType.BOOL));
      if (_notEquals_1) {
        this.error("Expressão E não pode operar em cima deste tipo", 
          AnsicPackage.Literals.AND_EXPRESSION__EQUALITY_EXPRESSION);
      }
      and_expression_linha _and_expression_linha_1 = andExp.getAnd_expression_linha();
      equality_expression _equality_expression_1 = _and_expression_linha_1.getEquality_expression();
      relational_expression _relational_expression_1 = _equality_expression_1.getRelational_expression();
      shift_expression _shift_expression_1 = _relational_expression_1.getShift_expression();
      additive_expression _additive_expression_1 = _shift_expression_1.getAdditive_expression();
      multiplicative_expression _multiplicative_expression_1 = _additive_expression_1.getMultiplicative_expression();
      cast_expression _cast_expression_1 = _multiplicative_expression_1.getCast_expression();
      unary_expression _unary_expression_1 = _cast_expression_1.getUnary_expression();
      postfix_expression _postfix_expression_1 = _unary_expression_1.getPostfix_expression();
      primary_expression rSide = _postfix_expression_1.getPrimary_expression();
      AnsicValidator.ExpRetType rType = this.evaluateExp(rSide);
      boolean _notEquals_2 = (!Objects.equal(rType, AnsicValidator.ExpRetType.BOOL));
      if (_notEquals_2) {
        this.error("Expressão E pode operar em cima deste tipo", 
          AnsicPackage.Literals.AND_EXPRESSION__AND_EXPRESSION_LINHA);
      }
      boolean _notEquals_3 = (!Objects.equal(rType, lType));
      if (_notEquals_3) {
        this.error("Tipos incompativeis na operação aditiva", 
          null);
      }
    }
  }
  
  @Check
  public void CheckRelationalExp(final relational_expression relExp) {
    relational_expression_linha _relational_expression_linha = relExp.getRelational_expression_linha();
    boolean _notEquals = (!Objects.equal(_relational_expression_linha, null));
    if (_notEquals) {
      shift_expression _shift_expression = relExp.getShift_expression();
      additive_expression _additive_expression = _shift_expression.getAdditive_expression();
      multiplicative_expression _multiplicative_expression = _additive_expression.getMultiplicative_expression();
      cast_expression _cast_expression = _multiplicative_expression.getCast_expression();
      unary_expression _unary_expression = _cast_expression.getUnary_expression();
      postfix_expression _postfix_expression = _unary_expression.getPostfix_expression();
      primary_expression currentExp = _postfix_expression.getPrimary_expression();
      AnsicValidator.ExpRetType lType = this.evaluateExp(currentExp);
      boolean _equals = Objects.equal(lType, AnsicValidator.ExpRetType.BOOL);
      if (_equals) {
        this.error("Expressão relacional não pode operar em cima deste tipo", 
          null);
      }
      relational_expression_linha _relational_expression_linha_1 = relExp.getRelational_expression_linha();
      shift_expression_complement _shift_expression_complement = _relational_expression_linha_1.getShift_expression_complement();
      additive_expression _additive_expression_1 = _shift_expression_complement.getAdditive_expression();
      multiplicative_expression _multiplicative_expression_1 = _additive_expression_1.getMultiplicative_expression();
      cast_expression _cast_expression_1 = _multiplicative_expression_1.getCast_expression();
      unary_expression _unary_expression_1 = _cast_expression_1.getUnary_expression();
      postfix_expression _postfix_expression_1 = _unary_expression_1.getPostfix_expression();
      primary_expression rSide = _postfix_expression_1.getPrimary_expression();
      AnsicValidator.ExpRetType rType = this.evaluateExp(rSide);
      boolean _equals_1 = Objects.equal(rType, AnsicValidator.ExpRetType.BOOL);
      if (_equals_1) {
        this.error("Expressão relacional pode operar em cima deste tipo", 
          AnsicPackage.Literals.RELATIONAL_EXPRESSION__RELATIONAL_EXPRESSION_LINHA);
      }
      boolean _notEquals_1 = (!Objects.equal(rType, lType));
      if (_notEquals_1) {
        this.error("Tipos incompativeis na operação aditiva", 
          null);
      }
    }
  }
  
  @Check
  public void CheckExclusiveOrExp(final exclusive_or_expression orExp) {
    exclusive_or_expression_linha _exclusive_or_expression_linha = orExp.getExclusive_or_expression_linha();
    boolean _notEquals = (!Objects.equal(_exclusive_or_expression_linha, null));
    if (_notEquals) {
      and_expression _and_expression = orExp.getAnd_expression();
      equality_expression _equality_expression = _and_expression.getEquality_expression();
      relational_expression _relational_expression = _equality_expression.getRelational_expression();
      shift_expression _shift_expression = _relational_expression.getShift_expression();
      additive_expression _additive_expression = _shift_expression.getAdditive_expression();
      multiplicative_expression _multiplicative_expression = _additive_expression.getMultiplicative_expression();
      cast_expression _cast_expression = _multiplicative_expression.getCast_expression();
      unary_expression _unary_expression = _cast_expression.getUnary_expression();
      postfix_expression _postfix_expression = _unary_expression.getPostfix_expression();
      primary_expression currentExp = _postfix_expression.getPrimary_expression();
      AnsicValidator.ExpRetType lType = this.evaluateExp(currentExp);
      boolean _notEquals_1 = (!Objects.equal(lType, AnsicValidator.ExpRetType.BOOL));
      if (_notEquals_1) {
        this.error("Expressão ou exclusivo pode operar em cima deste tipo", 
          AnsicPackage.Literals.EXCLUSIVE_OR_EXPRESSION__AND_EXPRESSION);
      }
      exclusive_or_expression_linha _exclusive_or_expression_linha_1 = orExp.getExclusive_or_expression_linha();
      and_expression _and_expression_1 = _exclusive_or_expression_linha_1.getAnd_expression();
      equality_expression _equality_expression_1 = _and_expression_1.getEquality_expression();
      relational_expression _relational_expression_1 = _equality_expression_1.getRelational_expression();
      shift_expression _shift_expression_1 = _relational_expression_1.getShift_expression();
      additive_expression _additive_expression_1 = _shift_expression_1.getAdditive_expression();
      multiplicative_expression _multiplicative_expression_1 = _additive_expression_1.getMultiplicative_expression();
      cast_expression _cast_expression_1 = _multiplicative_expression_1.getCast_expression();
      unary_expression _unary_expression_1 = _cast_expression_1.getUnary_expression();
      postfix_expression _postfix_expression_1 = _unary_expression_1.getPostfix_expression();
      primary_expression rSide = _postfix_expression_1.getPrimary_expression();
      AnsicValidator.ExpRetType rType = this.evaluateExp(rSide);
      boolean _notEquals_2 = (!Objects.equal(rType, AnsicValidator.ExpRetType.BOOL));
      if (_notEquals_2) {
        this.error("Expressão ou exclusivo pode operar em cima deste tipo", 
          AnsicPackage.Literals.EXCLUSIVE_OR_EXPRESSION__EXCLUSIVE_OR_EXPRESSION_LINHA);
      }
      boolean _notEquals_3 = (!Objects.equal(rType, lType));
      if (_notEquals_3) {
        this.error("Tipos incompativeis na operação aditiva", 
          null);
      }
    }
  }
  
  @Check
  public void CheckInclusiveOrExp(final inclusive_or_expression orExp) {
    inclusive_or_expression_linha _inclusive_or_expression_linha = orExp.getInclusive_or_expression_linha();
    boolean _notEquals = (!Objects.equal(_inclusive_or_expression_linha, null));
    if (_notEquals) {
      exclusive_or_expression _exclusive_or_expression = orExp.getExclusive_or_expression();
      and_expression _and_expression = _exclusive_or_expression.getAnd_expression();
      equality_expression _equality_expression = _and_expression.getEquality_expression();
      relational_expression _relational_expression = _equality_expression.getRelational_expression();
      shift_expression _shift_expression = _relational_expression.getShift_expression();
      additive_expression _additive_expression = _shift_expression.getAdditive_expression();
      multiplicative_expression _multiplicative_expression = _additive_expression.getMultiplicative_expression();
      cast_expression _cast_expression = _multiplicative_expression.getCast_expression();
      unary_expression _unary_expression = _cast_expression.getUnary_expression();
      postfix_expression _postfix_expression = _unary_expression.getPostfix_expression();
      primary_expression currentExp = _postfix_expression.getPrimary_expression();
      AnsicValidator.ExpRetType lType = this.evaluateExp(currentExp);
      boolean _notEquals_1 = (!Objects.equal(lType, AnsicValidator.ExpRetType.BOOL));
      if (_notEquals_1) {
        this.error("Expressão ou inclusivo pode operar em cima deste tipo", 
          AnsicPackage.Literals.INCLUSIVE_OR_EXPRESSION__EXCLUSIVE_OR_EXPRESSION);
      }
      inclusive_or_expression_linha _inclusive_or_expression_linha_1 = orExp.getInclusive_or_expression_linha();
      exclusive_or_expression _exclusive_or_expression_1 = _inclusive_or_expression_linha_1.getExclusive_or_expression();
      and_expression _and_expression_1 = _exclusive_or_expression_1.getAnd_expression();
      equality_expression _equality_expression_1 = _and_expression_1.getEquality_expression();
      relational_expression _relational_expression_1 = _equality_expression_1.getRelational_expression();
      shift_expression _shift_expression_1 = _relational_expression_1.getShift_expression();
      additive_expression _additive_expression_1 = _shift_expression_1.getAdditive_expression();
      multiplicative_expression _multiplicative_expression_1 = _additive_expression_1.getMultiplicative_expression();
      cast_expression _cast_expression_1 = _multiplicative_expression_1.getCast_expression();
      unary_expression _unary_expression_1 = _cast_expression_1.getUnary_expression();
      postfix_expression _postfix_expression_1 = _unary_expression_1.getPostfix_expression();
      primary_expression rSide = _postfix_expression_1.getPrimary_expression();
      AnsicValidator.ExpRetType rType = this.evaluateExp(rSide);
      boolean _notEquals_2 = (!Objects.equal(rType, AnsicValidator.ExpRetType.BOOL));
      if (_notEquals_2) {
        this.error("Expressão ou inclusivo pode operar em cima deste tipo", 
          AnsicPackage.Literals.INCLUSIVE_OR_EXPRESSION__INCLUSIVE_OR_EXPRESSION_LINHA);
      }
      boolean _notEquals_3 = (!Objects.equal(rType, lType));
      if (_notEquals_3) {
        this.error("Tipos incompativeis na operação aditiva", 
          null);
      }
    }
  }
  
  @Check
  public void CheckLogicalAndExp(final logical_and_expression andExp) {
    logical_and_expression_linha _logical_and_expression_linha = andExp.getLogical_and_expression_linha();
    boolean _notEquals = (!Objects.equal(_logical_and_expression_linha, null));
    if (_notEquals) {
      inclusive_or_expression _inclusive_or_expression = andExp.getInclusive_or_expression();
      exclusive_or_expression _exclusive_or_expression = _inclusive_or_expression.getExclusive_or_expression();
      and_expression _and_expression = _exclusive_or_expression.getAnd_expression();
      equality_expression _equality_expression = _and_expression.getEquality_expression();
      relational_expression _relational_expression = _equality_expression.getRelational_expression();
      shift_expression _shift_expression = _relational_expression.getShift_expression();
      additive_expression _additive_expression = _shift_expression.getAdditive_expression();
      multiplicative_expression _multiplicative_expression = _additive_expression.getMultiplicative_expression();
      cast_expression _cast_expression = _multiplicative_expression.getCast_expression();
      unary_expression _unary_expression = _cast_expression.getUnary_expression();
      postfix_expression _postfix_expression = _unary_expression.getPostfix_expression();
      primary_expression currentExp = _postfix_expression.getPrimary_expression();
      AnsicValidator.ExpRetType lType = this.evaluateExp(currentExp);
      boolean _notEquals_1 = (!Objects.equal(lType, AnsicValidator.ExpRetType.BOOL));
      if (_notEquals_1) {
        this.error("Expressão E lógico pode operar em cima deste tipo", 
          AnsicPackage.Literals.LOGICAL_AND_EXPRESSION__INCLUSIVE_OR_EXPRESSION);
      }
      logical_and_expression_linha _logical_and_expression_linha_1 = andExp.getLogical_and_expression_linha();
      inclusive_or_expression _inclusive_or_expression_1 = _logical_and_expression_linha_1.getInclusive_or_expression();
      exclusive_or_expression _exclusive_or_expression_1 = _inclusive_or_expression_1.getExclusive_or_expression();
      and_expression _and_expression_1 = _exclusive_or_expression_1.getAnd_expression();
      equality_expression _equality_expression_1 = _and_expression_1.getEquality_expression();
      relational_expression _relational_expression_1 = _equality_expression_1.getRelational_expression();
      shift_expression _shift_expression_1 = _relational_expression_1.getShift_expression();
      additive_expression _additive_expression_1 = _shift_expression_1.getAdditive_expression();
      multiplicative_expression _multiplicative_expression_1 = _additive_expression_1.getMultiplicative_expression();
      cast_expression _cast_expression_1 = _multiplicative_expression_1.getCast_expression();
      unary_expression _unary_expression_1 = _cast_expression_1.getUnary_expression();
      postfix_expression _postfix_expression_1 = _unary_expression_1.getPostfix_expression();
      primary_expression rSide = _postfix_expression_1.getPrimary_expression();
      AnsicValidator.ExpRetType rType = this.evaluateExp(rSide);
      boolean _notEquals_2 = (!Objects.equal(rType, AnsicValidator.ExpRetType.BOOL));
      if (_notEquals_2) {
        this.error("Expressão E lógico pode operar em cima deste tipo", 
          AnsicPackage.Literals.LOGICAL_AND_EXPRESSION__LOGICAL_AND_EXPRESSION_LINHA);
      }
      boolean _notEquals_3 = (!Objects.equal(rType, lType));
      if (_notEquals_3) {
        this.error("Tipos incompativeis na operação aditiva", 
          null);
      }
    }
  }
  
  @Check
  public void CheckLogicalOrExp(final logical_or_expression orExp) {
    logical_or_expression_linha _logical_or_expression_linha = orExp.getLogical_or_expression_linha();
    boolean _notEquals = (!Objects.equal(_logical_or_expression_linha, null));
    if (_notEquals) {
      logical_and_expression _logical_and_expression = orExp.getLogical_and_expression();
      inclusive_or_expression _inclusive_or_expression = _logical_and_expression.getInclusive_or_expression();
      exclusive_or_expression _exclusive_or_expression = _inclusive_or_expression.getExclusive_or_expression();
      and_expression _and_expression = _exclusive_or_expression.getAnd_expression();
      equality_expression _equality_expression = _and_expression.getEquality_expression();
      relational_expression _relational_expression = _equality_expression.getRelational_expression();
      shift_expression _shift_expression = _relational_expression.getShift_expression();
      additive_expression _additive_expression = _shift_expression.getAdditive_expression();
      multiplicative_expression _multiplicative_expression = _additive_expression.getMultiplicative_expression();
      cast_expression _cast_expression = _multiplicative_expression.getCast_expression();
      unary_expression _unary_expression = _cast_expression.getUnary_expression();
      postfix_expression _postfix_expression = _unary_expression.getPostfix_expression();
      primary_expression currentExp = _postfix_expression.getPrimary_expression();
      AnsicValidator.ExpRetType lType = this.evaluateExp(currentExp);
      boolean _notEquals_1 = (!Objects.equal(lType, AnsicValidator.ExpRetType.BOOL));
      if (_notEquals_1) {
        this.error("Expressão ou lógico pode operar em cima deste tipo", 
          AnsicPackage.Literals.LOGICAL_OR_EXPRESSION__LOGICAL_AND_EXPRESSION);
      }
      logical_or_expression_linha _logical_or_expression_linha_1 = orExp.getLogical_or_expression_linha();
      logical_and_expression _logical_and_expression_1 = _logical_or_expression_linha_1.getLogical_and_expression();
      inclusive_or_expression _inclusive_or_expression_1 = _logical_and_expression_1.getInclusive_or_expression();
      exclusive_or_expression _exclusive_or_expression_1 = _inclusive_or_expression_1.getExclusive_or_expression();
      and_expression _and_expression_1 = _exclusive_or_expression_1.getAnd_expression();
      equality_expression _equality_expression_1 = _and_expression_1.getEquality_expression();
      relational_expression _relational_expression_1 = _equality_expression_1.getRelational_expression();
      shift_expression _shift_expression_1 = _relational_expression_1.getShift_expression();
      additive_expression _additive_expression_1 = _shift_expression_1.getAdditive_expression();
      multiplicative_expression _multiplicative_expression_1 = _additive_expression_1.getMultiplicative_expression();
      cast_expression _cast_expression_1 = _multiplicative_expression_1.getCast_expression();
      unary_expression _unary_expression_1 = _cast_expression_1.getUnary_expression();
      postfix_expression _postfix_expression_1 = _unary_expression_1.getPostfix_expression();
      primary_expression rSide = _postfix_expression_1.getPrimary_expression();
      AnsicValidator.ExpRetType rType = this.evaluateExp(rSide);
      boolean _notEquals_2 = (!Objects.equal(rType, AnsicValidator.ExpRetType.BOOL));
      if (_notEquals_2) {
        this.error("Expressão ou lógico pode operar em cima deste tipo", 
          AnsicPackage.Literals.LOGICAL_OR_EXPRESSION__LOGICAL_OR_EXPRESSION_LINHA);
      }
      boolean _notEquals_3 = (!Objects.equal(rType, lType));
      if (_notEquals_3) {
        this.error("Tipos incompativeis na operação aditiva", 
          null);
      }
    }
  }
  
  @Check
  public void CheckAdditiveExp(final additive_expression addExp) {
    additive_expression_linha _additive_expression_linha = addExp.getAdditive_expression_linha();
    boolean _notEquals = (!Objects.equal(_additive_expression_linha, null));
    if (_notEquals) {
      multiplicative_expression _multiplicative_expression = addExp.getMultiplicative_expression();
      cast_expression _cast_expression = _multiplicative_expression.getCast_expression();
      unary_expression _unary_expression = _cast_expression.getUnary_expression();
      postfix_expression _postfix_expression = _unary_expression.getPostfix_expression();
      primary_expression currentExp = _postfix_expression.getPrimary_expression();
      AnsicValidator.ExpRetType lType = this.evaluateExp(currentExp);
      boolean _equals = Objects.equal(lType, AnsicValidator.ExpRetType.BOOL);
      if (_equals) {
        this.error("Expressão aditiva pode operar em cima deste tipo", 
          AnsicPackage.Literals.ADDITIVE_EXPRESSION__MULTIPLICATIVE_EXPRESSION);
      }
      additive_expression_linha _additive_expression_linha_1 = addExp.getAdditive_expression_linha();
      additive_expression_complement _additive_expression_complement = _additive_expression_linha_1.getAdditive_expression_complement();
      multiplicative_expression _multiplicative_expression_1 = _additive_expression_complement.getMultiplicative_expression();
      cast_expression _cast_expression_1 = _multiplicative_expression_1.getCast_expression();
      unary_expression _unary_expression_1 = _cast_expression_1.getUnary_expression();
      postfix_expression _postfix_expression_1 = _unary_expression_1.getPostfix_expression();
      primary_expression rSide = _postfix_expression_1.getPrimary_expression();
      AnsicValidator.ExpRetType rType = this.evaluateExp(rSide);
      boolean _equals_1 = Objects.equal(rType, AnsicValidator.ExpRetType.BOOL);
      if (_equals_1) {
        this.error("Expressão aditiva pode operar em cima deste tipo", 
          AnsicPackage.Literals.ADDITIVE_EXPRESSION__ADDITIVE_EXPRESSION_LINHA);
      }
      boolean _notEquals_1 = (!Objects.equal(rType, lType));
      if (_notEquals_1) {
        this.error("Tipos incompativeis na operação aditiva", 
          null);
      }
    }
  }
  
  @Check
  public void CheckShiftExp(final shift_expression shiftExp) {
    shift_expression_linha _shift_expression_linha = shiftExp.getShift_expression_linha();
    boolean _notEquals = (!Objects.equal(_shift_expression_linha, null));
    if (_notEquals) {
      additive_expression _additive_expression = shiftExp.getAdditive_expression();
      multiplicative_expression _multiplicative_expression = _additive_expression.getMultiplicative_expression();
      cast_expression _cast_expression = _multiplicative_expression.getCast_expression();
      unary_expression _unary_expression = _cast_expression.getUnary_expression();
      postfix_expression _postfix_expression = _unary_expression.getPostfix_expression();
      primary_expression currentExp = _postfix_expression.getPrimary_expression();
      AnsicValidator.ExpRetType lType = this.evaluateExp(currentExp);
      boolean _equals = Objects.equal(lType, AnsicValidator.ExpRetType.BOOL);
      if (_equals) {
        this.error("Expressão aditiva pode operar em cima deste tipo", 
          AnsicPackage.Literals.SHIFT_EXPRESSION__ADDITIVE_EXPRESSION);
      }
      shift_expression_linha _shift_expression_linha_1 = shiftExp.getShift_expression_linha();
      shift_expression_complement _shift_expression_complement = _shift_expression_linha_1.getShift_expression_complement();
      additive_expression _additive_expression_1 = _shift_expression_complement.getAdditive_expression();
      multiplicative_expression _multiplicative_expression_1 = _additive_expression_1.getMultiplicative_expression();
      cast_expression _cast_expression_1 = _multiplicative_expression_1.getCast_expression();
      unary_expression _unary_expression_1 = _cast_expression_1.getUnary_expression();
      postfix_expression _postfix_expression_1 = _unary_expression_1.getPostfix_expression();
      primary_expression rSide = _postfix_expression_1.getPrimary_expression();
      AnsicValidator.ExpRetType rType = this.evaluateExp(rSide);
      boolean _equals_1 = Objects.equal(rType, AnsicValidator.ExpRetType.BOOL);
      if (_equals_1) {
        this.error("Expressão aditiva pode operar em cima deste tipo", 
          AnsicPackage.Literals.SHIFT_EXPRESSION__SHIFT_EXPRESSION_LINHA);
      }
      boolean _notEquals_1 = (!Objects.equal(rType, lType));
      if (_notEquals_1) {
        this.error("Tipos incompativeis na operação aditiva", 
          null);
      }
    }
  }
  
  @Check
  public void CheckMultiplicativeExp(final multiplicative_expression mulExp) {
    multiplicative_expression_linha _multiplicative_expression_linha = mulExp.getMultiplicative_expression_linha();
    boolean _notEquals = (!Objects.equal(_multiplicative_expression_linha, null));
    if (_notEquals) {
      cast_expression _cast_expression = mulExp.getCast_expression();
      unary_expression _unary_expression = _cast_expression.getUnary_expression();
      postfix_expression _postfix_expression = _unary_expression.getPostfix_expression();
      primary_expression currentExp = _postfix_expression.getPrimary_expression();
      AnsicValidator.ExpRetType lType = this.evaluateExp(currentExp);
      boolean _equals = Objects.equal(lType, AnsicValidator.ExpRetType.BOOL);
      if (_equals) {
        this.error("Expressão multiplicativa não pode operar em cima deste tipo", 
          AnsicPackage.Literals.MULTIPLICATIVE_EXPRESSION__CAST_EXPRESSION);
      }
      multiplicative_expression_linha _multiplicative_expression_linha_1 = mulExp.getMultiplicative_expression_linha();
      multiplicative_expression_complement _multiplicative_expression_complement = _multiplicative_expression_linha_1.getMultiplicative_expression_complement();
      cast_expression _cast_expression_1 = _multiplicative_expression_complement.getCast_expression();
      unary_expression _unary_expression_1 = _cast_expression_1.getUnary_expression();
      postfix_expression _postfix_expression_1 = _unary_expression_1.getPostfix_expression();
      primary_expression rSide = _postfix_expression_1.getPrimary_expression();
      AnsicValidator.ExpRetType rType = this.evaluateExp(rSide);
      boolean _equals_1 = Objects.equal(rType, AnsicValidator.ExpRetType.BOOL);
      if (_equals_1) {
        this.error("Expressão multiplicativa pode operar em cima deste tipo", 
          AnsicPackage.Literals.MULTIPLICATIVE_EXPRESSION__MULTIPLICATIVE_EXPRESSION_LINHA);
      }
      boolean _notEquals_1 = (!Objects.equal(rType, lType));
      if (_notEquals_1) {
        this.error("Tipos incompativeis na operação multiplicativa", 
          null);
      }
    }
  }
  
  @Check
  public String checkFunctionCall(final postfix_expression_complement call) {
    String _xblockexpression = null;
    {
      EObject _eContainer = call.eContainer();
      EObject _eContainer_1 = _eContainer.eContainer();
      postfix_expression parent = ((postfix_expression) _eContainer_1);
      primary_expression _primary_expression = parent.getPrimary_expression();
      String name = _primary_expression.getIdentifier();
      String _xifexpression = null;
      boolean _containsKey = this.functions.containsKey(name);
      boolean _not = (!_containsKey);
      if (_not) {
        this.error("Função não definida", 
          null);
      } else {
        String _xblockexpression_1 = null;
        {
          AnsicValidator.Function func = this.functions.get(name);
          int _size = func.params_types.size();
          String _plus = ((("Checking params for: " + func.name) + " With: ") + Integer.valueOf(_size));
          String _plus_1 = (_plus + " params.");
          InputOutput.<String>println(_plus_1);
          String _xifexpression_1 = null;
          argument_expression_list _argument_expression_list = call.getArgument_expression_list();
          EList<assignment_expression> _assignment_expressions = _argument_expression_list.getAssignment_expressions();
          int _size_1 = _assignment_expressions.size();
          boolean _notEquals = (func.param_number != _size_1);
          if (_notEquals) {
            this.error("Numero de parametros incompativeis", 
              AnsicPackage.Literals.POSTFIX_EXPRESSION_COMPLEMENT__ARGUMENT_EXPRESSION_LIST);
          } else {
            String _xblockexpression_2 = null;
            {
              for (int i = 0; (i < call.getArgument_expression_list().getAssignment_expressions().size()); i++) {
                {
                  argument_expression_list _argument_expression_list_1 = call.getArgument_expression_list();
                  EList<assignment_expression> _assignment_expressions_1 = _argument_expression_list_1.getAssignment_expressions();
                  assignment_expression arg = _assignment_expressions_1.get(i);
                  argument_expression_list _argument_expression_list_2 = call.getArgument_expression_list();
                  EList<assignment_expression> _assignment_expressions_2 = _argument_expression_list_2.getAssignment_expressions();
                  int _size_2 = _assignment_expressions_2.size();
                  String _plus_2 = ("Size: " + Integer.valueOf(_size_2));
                  InputOutput.<String>println(_plus_2);
                  InputOutput.<String>println(("For: " + Integer.valueOf(i)));
                  String argType = func.params_types.get(i);
                  AnsicValidator.ExpRetType _expType = this.getExpType(arg);
                  boolean _notEquals_1 = (!Objects.equal(_expType, null));
                  if (_notEquals_1) {
                    InputOutput.<String>println("Is an expression");
                    AnsicValidator.ExpRetType expRet = this.getExpType(arg);
                    boolean _equals = Objects.equal(expRet, AnsicValidator.ExpRetType.NUMERIC);
                    if (_equals) {
                      boolean _equals_1 = Objects.equal(argType, "bool");
                      if (_equals_1) {
                        this.error("Tipo de parametro não compativel", 
                          AnsicPackage.Literals.POSTFIX_EXPRESSION_COMPLEMENT__ARGUMENT_EXPRESSION_LIST);
                      }
                    } else {
                      boolean _equals_2 = Objects.equal(expRet, AnsicValidator.ExpRetType.BOOL);
                      if (_equals_2) {
                        boolean _notEquals_2 = (!Objects.equal(argType, "bool"));
                        if (_notEquals_2) {
                          this.error("Tipo de parametro não compativel", 
                            AnsicPackage.Literals.POSTFIX_EXPRESSION_COMPLEMENT__ARGUMENT_EXPRESSION_LIST);
                        }
                      }
                    }
                  } else {
                    InputOutput.<String>println("Is an contant or id");
                    primary_expression idOrCons = this.primaryExpFromAssigExp(arg);
                    InputOutput.<String>println("CP1");
                    boolean _and = false;
                    String _identifier = idOrCons.getIdentifier();
                    boolean _notEquals_3 = (!Objects.equal(_identifier, null));
                    if (!_notEquals_3) {
                      _and = false;
                    } else {
                      String _identifier_1 = idOrCons.getIdentifier();
                      String _trim = _identifier_1.trim();
                      boolean _isEmpty = _trim.isEmpty();
                      boolean _not_1 = (!_isEmpty);
                      _and = _not_1;
                    }
                    if (_and) {
                      InputOutput.<String>println("CP2");
                      String _identifier_2 = idOrCons.getIdentifier();
                      boolean _containsKey_1 = this.variables.containsKey(_identifier_2);
                      if (_containsKey_1) {
                        String _identifier_3 = idOrCons.getIdentifier();
                        String _get = this.variables.get(_identifier_3);
                        boolean _notEquals_4 = (!Objects.equal(_get, argType));
                        if (_notEquals_4) {
                          InputOutput.<String>println("CP3");
                          this.error("Tipo de parametro não compativel", 
                            AnsicPackage.Literals.POSTFIX_EXPRESSION_COMPLEMENT__ARGUMENT_EXPRESSION_LIST);
                        }
                      } else {
                        String _identifier_4 = idOrCons.getIdentifier();
                        boolean _containsKey_2 = this.functions.containsKey(_identifier_4);
                        if (_containsKey_2) {
                          String _identifier_5 = idOrCons.getIdentifier();
                          AnsicValidator.Function _get_1 = this.functions.get(_identifier_5);
                          boolean _notEquals_5 = (!Objects.equal(_get_1.retType, argType));
                          if (_notEquals_5) {
                            this.error("Tipo de parametro não compativel", 
                              AnsicPackage.Literals.POSTFIX_EXPRESSION_COMPLEMENT__ARGUMENT_EXPRESSION_LIST);
                          }
                        }
                      }
                    }
                    InputOutput.<String>println("CP4");
                    boolean _and_1 = false;
                    boolean _and_2 = false;
                    constant _constant = idOrCons.getConstant();
                    boolean _notEquals_6 = (!Objects.equal(_constant, null));
                    if (!_notEquals_6) {
                      _and_2 = false;
                    } else {
                      constant _constant_1 = idOrCons.getConstant();
                      String _char = _constant_1.getChar();
                      boolean _notEquals_7 = (!Objects.equal(_char, null));
                      _and_2 = _notEquals_7;
                    }
                    if (!_and_2) {
                      _and_1 = false;
                    } else {
                      boolean _notEquals_8 = (!Objects.equal(argType, "char"));
                      _and_1 = _notEquals_8;
                    }
                    if (_and_1) {
                      InputOutput.<String>println("CP5");
                      this.error("Tipo de parametro não com \tpativel", 
                        AnsicPackage.Literals.POSTFIX_EXPRESSION_COMPLEMENT__ARGUMENT_EXPRESSION_LIST);
                    }
                    InputOutput.<String>println("CP7");
                  }
                  InputOutput.<String>println("End of iteration");
                }
              }
              _xblockexpression_2 = InputOutput.<String>println("For ended");
            }
            _xifexpression_1 = _xblockexpression_2;
          }
          _xblockexpression_1 = _xifexpression_1;
        }
        _xifexpression = _xblockexpression_1;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  @Check
  public void checkPrimaryExpression(final primary_expression exp) {
    boolean _and = false;
    String _identifier = exp.getIdentifier();
    boolean _notEquals = (!Objects.equal(_identifier, null));
    if (!_notEquals) {
      _and = false;
    } else {
      String _identifier_1 = exp.getIdentifier();
      String _trim = _identifier_1.trim();
      boolean _isEmpty = _trim.isEmpty();
      boolean _not = (!_isEmpty);
      _and = _not;
    }
    if (_and) {
      boolean _and_1 = false;
      String _identifier_2 = exp.getIdentifier();
      boolean _containsKey = this.variables.containsKey(_identifier_2);
      boolean _not_1 = (!_containsKey);
      if (!_not_1) {
        _and_1 = false;
      } else {
        String _identifier_3 = exp.getIdentifier();
        boolean _containsKey_1 = this.functions.containsKey(_identifier_3);
        boolean _not_2 = (!_containsKey_1);
        _and_1 = _not_2;
      }
      if (_and_1) {
        this.error("Variavel não declarada", 
          AnsicPackage.Literals.PRIMARY_EXPRESSION__IDENTIFIER);
      }
    }
  }
  
  @Check
  public Object checkDeclarationTypes(final declaration decl) {
    Object _xblockexpression = null;
    {
      EList<declaration_specifiers> _declaration_specifiers = decl.getDeclaration_specifiers();
      declaration_specifiers _get = _declaration_specifiers.get(0);
      type_specifier _type_specifier = _get.getType_specifier();
      String leftType = _type_specifier.getType_name_str();
      EList<init_declarator_list> _init_declarator_list = decl.getInit_declarator_list();
      init_declarator_list _get_1 = _init_declarator_list.get(0);
      init_declarator _init_declarator = _get_1.getInit_declarator();
      declarator _declarator = _init_declarator.getDeclarator();
      direct_declarator _direct_declarator = _declarator.getDirect_declarator();
      String id = _direct_declarator.getIdentifier();
      boolean _containsKey = this.variables.containsKey(id);
      if (_containsKey) {
        this.error("Variável já declarada", null);
      }
      this.variables.put(id, leftType);
      EList<init_declarator_list> _init_declarator_list_1 = decl.getInit_declarator_list();
      init_declarator_list _get_2 = _init_declarator_list_1.get(0);
      init_declarator _init_declarator_1 = _get_2.getInit_declarator();
      initializer _initializer = _init_declarator_1.getInitializer();
      assignment_expression _assignment_expression = _initializer.getAssignment_expression();
      AnsicValidator.ExpRetType _expType = this.getExpType(_assignment_expression);
      boolean _equals = Objects.equal(_expType, null);
      if (_equals) {
      } else {
        EList<init_declarator_list> _init_declarator_list_2 = decl.getInit_declarator_list();
        init_declarator_list _get_3 = _init_declarator_list_2.get(0);
        init_declarator _init_declarator_2 = _get_3.getInit_declarator();
        initializer _initializer_1 = _init_declarator_2.getInitializer();
        assignment_expression _assignment_expression_1 = _initializer_1.getAssignment_expression();
        AnsicValidator.ExpRetType expType = this.getExpType(_assignment_expression_1);
        boolean _equals_1 = Objects.equal(expType, AnsicValidator.ExpRetType.NUMERIC);
        if (_equals_1) {
          boolean _or = false;
          boolean _equals_2 = Objects.equal(leftType, "bool");
          if (_equals_2) {
            _or = true;
          } else {
            boolean _equals_3 = Objects.equal(leftType, "char");
            _or = _equals_3;
          }
          if (_or) {
            this.error(
              "Tipos incompativeis para atribuição", 
              AnsicPackage.Literals.DECLARATION__INIT_DECLARATOR_LIST);
          }
        } else {
          boolean _equals_4 = Objects.equal(expType, AnsicValidator.ExpRetType.BOOL);
          if (_equals_4) {
            boolean _notEquals = (!Objects.equal(leftType, "bool"));
            if (_notEquals) {
              this.error(
                "Não é possível atribuir retorno booleano para o tipo declarado", 
                AnsicPackage.Literals.DECLARATION__INIT_DECLARATOR_LIST);
            }
          }
        }
      }
      EList<init_declarator_list> _init_declarator_list_3 = decl.getInit_declarator_list();
      init_declarator_list _get_4 = _init_declarator_list_3.get(0);
      init_declarator _init_declarator_3 = _get_4.getInit_declarator();
      initializer _initializer_2 = _init_declarator_3.getInitializer();
      assignment_expression _assignment_expression_2 = _initializer_2.getAssignment_expression();
      conditional_expression _conditional_expression = _assignment_expression_2.getConditional_expression();
      logical_or_expression _logical_or_expression = _conditional_expression.getLogical_or_expression();
      logical_and_expression _logical_and_expression = _logical_or_expression.getLogical_and_expression();
      inclusive_or_expression _inclusive_or_expression = _logical_and_expression.getInclusive_or_expression();
      exclusive_or_expression _exclusive_or_expression = _inclusive_or_expression.getExclusive_or_expression();
      and_expression _and_expression = _exclusive_or_expression.getAnd_expression();
      equality_expression _equality_expression = _and_expression.getEquality_expression();
      relational_expression _relational_expression = _equality_expression.getRelational_expression();
      shift_expression _shift_expression = _relational_expression.getShift_expression();
      additive_expression _additive_expression = _shift_expression.getAdditive_expression();
      multiplicative_expression _multiplicative_expression = _additive_expression.getMultiplicative_expression();
      cast_expression _cast_expression = _multiplicative_expression.getCast_expression();
      unary_expression _unary_expression = _cast_expression.getUnary_expression();
      postfix_expression _postfix_expression = _unary_expression.getPostfix_expression();
      primary_expression rightType = _postfix_expression.getPrimary_expression();
      Object _xifexpression = null;
      constant _constant = rightType.getConstant();
      boolean _notEquals_1 = (!Objects.equal(_constant, null));
      if (_notEquals_1) {
        this.checkDeclarationWithConstant(leftType, rightType);
      } else {
        Object _xifexpression_1 = null;
        boolean _and = false;
        String _identifier = rightType.getIdentifier();
        boolean _notEquals_2 = (!Objects.equal(_identifier, null));
        if (!_notEquals_2) {
          _and = false;
        } else {
          String _identifier_1 = rightType.getIdentifier();
          String _trim = _identifier_1.trim();
          boolean _isEmpty = _trim.isEmpty();
          boolean _not = (!_isEmpty);
          _and = _not;
        }
        if (_and) {
          Object _xifexpression_2 = null;
          boolean _and_1 = false;
          boolean _or_1 = false;
          String _identifier_2 = rightType.getIdentifier();
          boolean _containsKey_1 = this.variables.containsKey(_identifier_2);
          if (_containsKey_1) {
            _or_1 = true;
          } else {
            String _identifier_3 = rightType.getIdentifier();
            boolean _containsKey_2 = this.functions.containsKey(_identifier_3);
            _or_1 = _containsKey_2;
          }
          if (!_or_1) {
            _and_1 = false;
          } else {
            EList<init_declarator_list> _init_declarator_list_4 = decl.getInit_declarator_list();
            init_declarator_list _get_5 = _init_declarator_list_4.get(0);
            init_declarator _init_declarator_4 = _get_5.getInit_declarator();
            initializer _initializer_3 = _init_declarator_4.getInitializer();
            assignment_expression _assignment_expression_3 = _initializer_3.getAssignment_expression();
            AnsicValidator.ExpRetType _expType_1 = this.getExpType(_assignment_expression_3);
            boolean _equals_5 = Objects.equal(_expType_1, null);
            _and_1 = _equals_5;
          }
          if (_and_1) {
            String _identifier_4 = rightType.getIdentifier();
            boolean _containsKey_3 = this.variables.containsKey(_identifier_4);
            if (_containsKey_3) {
              String _identifier_5 = rightType.getIdentifier();
              String varType = this.variables.get(_identifier_5);
              boolean _notEquals_3 = (!Objects.equal(varType, leftType));
              if (_notEquals_3) {
                this.error("Tipos não compatíveis", 
                  AnsicPackage.Literals.DECLARATION__INIT_DECLARATOR_LIST);
              }
            } else {
              String _identifier_6 = rightType.getIdentifier();
              boolean _containsKey_4 = this.functions.containsKey(_identifier_6);
              if (_containsKey_4) {
                String _identifier_7 = rightType.getIdentifier();
                AnsicValidator.Function _get_6 = this.functions.get(_identifier_7);
                String retType = _get_6.retType;
                boolean _notEquals_4 = (!Objects.equal(retType, leftType));
                if (_notEquals_4) {
                  this.error("Retorno de função não compativel com tipo de variavel", 
                    AnsicPackage.Literals.DECLARATION__INIT_DECLARATOR_LIST);
                }
              }
            }
            String _identifier_8 = rightType.getIdentifier();
            String rType = this.variables.get(_identifier_8);
            boolean _and_2 = false;
            boolean _equals_6 = Objects.equal(leftType, "enum");
            if (!_equals_6) {
              _and_2 = false;
            } else {
              boolean _notEquals_5 = (!Objects.equal(rightType, "enum"));
              _and_2 = _notEquals_5;
            }
            if (_and_2) {
              this.error("A variavel deve ser um enum", 
                AnsicPackage.Literals.DECLARATION__INIT_DECLARATOR_LIST);
            }
          } else {
            _xifexpression_2 = null;
          }
          _xifexpression_1 = _xifexpression_2;
        } else {
          Object _xifexpression_3 = null;
          expression _expression = rightType.getExpression();
          boolean _notEquals_6 = (!Objects.equal(_expression, null));
          if (_notEquals_6) {
            _xifexpression_3 = null;
          }
          _xifexpression_1 = _xifexpression_3;
        }
        _xifexpression = _xifexpression_1;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  public void validateActribWithId(final String idLeft, final String idRight) {
    Set<String> _keySet = this.variables.keySet();
    boolean _contains = _keySet.contains(idRight);
    boolean _not = (!_contains);
    if (_not) {
      this.error("Variavel não declarada", 
        AnsicPackage.Literals.ASSIGNMENT_EXPRESSION__ASSIGNMENT_EXPRESSION);
    }
    String tr = this.variables.get(idRight);
    String tl = this.variables.get(idLeft);
    this.validateAlarg(tr, tl);
  }
  
  @Check
  public String checkEnumValid(final enum_specifier enumz) {
    String _xifexpression = null;
    String _identifier = enumz.getIdentifier();
    boolean _notEquals = (!Objects.equal(_identifier, null));
    if (_notEquals) {
      String _xifexpression_1 = null;
      String _identifier_1 = enumz.getIdentifier();
      boolean _containsKey = this.variables.containsKey(_identifier_1);
      if (_containsKey) {
        this.error("Variável já declarada", 
          AnsicPackage.Literals.ENUM_SPECIFIER__IDENTIFIER);
      } else {
        String _identifier_2 = enumz.getIdentifier();
        _xifexpression_1 = this.variables.put(_identifier_2, "enum");
      }
      _xifexpression = _xifexpression_1;
    }
    return _xifexpression;
  }
  
  @Check
  public void checkAtribType(final assignment_expression asexp) {
    unary_expression _unary_expression = asexp.getUnary_expression();
    postfix_expression _postfix_expression = _unary_expression.getPostfix_expression();
    primary_expression _primary_expression = _postfix_expression.getPrimary_expression();
    String idLeft = _primary_expression.getIdentifier();
    String argType = this.variables.get(idLeft);
    Set<String> _keySet = this.variables.keySet();
    boolean _contains = _keySet.contains(idLeft);
    boolean _not = (!_contains);
    if (_not) {
      this.error("Variavel não declarada", 
        AnsicPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION);
    }
    boolean _and = false;
    assignment_expression _assignment_expression = asexp.getAssignment_expression();
    boolean _notEquals = (!Objects.equal(_assignment_expression, null));
    if (!_notEquals) {
      _and = false;
    } else {
      assignment_expression _assignment_expression_1 = asexp.getAssignment_expression();
      AnsicValidator.ExpRetType _expType = this.getExpType(_assignment_expression_1);
      boolean _notEquals_1 = (!Objects.equal(_expType, null));
      _and = _notEquals_1;
    }
    if (_and) {
      assignment_expression arg = asexp.getAssignment_expression();
      InputOutput.<String>println("Is an expressionz");
      AnsicValidator.ExpRetType expRet = this.getExpType(arg);
      boolean _equals = Objects.equal(expRet, AnsicValidator.ExpRetType.NUMERIC);
      if (_equals) {
        boolean _equals_1 = Objects.equal(argType, "bool");
        if (_equals_1) {
          this.error("Variavel não compativel com este tipo", 
            null);
        }
      } else {
        boolean _equals_2 = Objects.equal(expRet, AnsicValidator.ExpRetType.BOOL);
        if (_equals_2) {
          boolean _notEquals_2 = (!Objects.equal(argType, "bool"));
          if (_notEquals_2) {
            this.error("Tipo de parametro não compativel", 
              null);
          }
        }
      }
    } else {
      InputOutput.<String>println("Eh um id oyu consz");
      assignment_expression _assignment_expression_2 = asexp.getAssignment_expression();
      primary_expression idOrCons = this.primaryExpFromAssigExp(_assignment_expression_2);
      boolean _and_1 = false;
      String _identifier = idOrCons.getIdentifier();
      boolean _notEquals_3 = (!Objects.equal(_identifier, null));
      if (!_notEquals_3) {
        _and_1 = false;
      } else {
        String _identifier_1 = idOrCons.getIdentifier();
        String _trim = _identifier_1.trim();
        boolean _isEmpty = _trim.isEmpty();
        boolean _not_1 = (!_isEmpty);
        _and_1 = _not_1;
      }
      if (_and_1) {
        String _identifier_2 = idOrCons.getIdentifier();
        boolean _containsKey = this.variables.containsKey(_identifier_2);
        if (_containsKey) {
          String _identifier_3 = idOrCons.getIdentifier();
          String _get = this.variables.get(_identifier_3);
          boolean _notEquals_4 = (!Objects.equal(_get, argType));
          if (_notEquals_4) {
            this.error("Variavel não compativel com este tipo", 
              null);
          }
        } else {
          String _identifier_4 = idOrCons.getIdentifier();
          boolean _containsKey_1 = this.functions.containsKey(_identifier_4);
          if (_containsKey_1) {
            String _identifier_5 = idOrCons.getIdentifier();
            AnsicValidator.Function _get_1 = this.functions.get(_identifier_5);
            boolean _notEquals_5 = (!Objects.equal(_get_1.retType, argType));
            if (_notEquals_5) {
              this.error("Variavel não compativel com este tipo", 
                null);
            }
          }
        }
      }
      boolean _and_2 = false;
      boolean _and_3 = false;
      constant _constant = idOrCons.getConstant();
      boolean _notEquals_6 = (!Objects.equal(_constant, null));
      if (!_notEquals_6) {
        _and_3 = false;
      } else {
        constant _constant_1 = idOrCons.getConstant();
        String _char = _constant_1.getChar();
        boolean _notEquals_7 = (!Objects.equal(_char, null));
        _and_3 = _notEquals_7;
      }
      if (!_and_3) {
        _and_2 = false;
      } else {
        boolean _notEquals_8 = (!Objects.equal(argType, "char"));
        _and_2 = _notEquals_8;
      }
      if (_and_2) {
        this.error("Variavel não compativel com este tipo", 
          null);
      }
    }
  }
  
  public void validateAlarg(final String tr, final String tl) {
    boolean _and = false;
    boolean _equals = Objects.equal(tl, "int");
    if (!_equals) {
      _and = false;
    } else {
      boolean _equals_1 = Objects.equal(tr, "float");
      _and = _equals_1;
    }
    if (_and) {
      this.error("Tipos incompativeis, De float para int", 
        AnsicPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION);
    }
    boolean _and_1 = false;
    boolean _equals_2 = Objects.equal(tl, "int");
    if (!_equals_2) {
      _and_1 = false;
    } else {
      boolean _equals_3 = Objects.equal(tr, "double");
      _and_1 = _equals_3;
    }
    if (_and_1) {
      this.error("Tipos incompativeis, De double para int", 
        AnsicPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION);
    }
    boolean _and_2 = false;
    boolean _equals_4 = Objects.equal(tl, "short");
    if (!_equals_4) {
      _and_2 = false;
    } else {
      boolean _equals_5 = Objects.equal(tr, "float");
      _and_2 = _equals_5;
    }
    if (_and_2) {
      this.error("Tipos incompativeis, De float para short", 
        AnsicPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION);
    }
    boolean _and_3 = false;
    boolean _equals_6 = Objects.equal(tl, "short");
    if (!_equals_6) {
      _and_3 = false;
    } else {
      boolean _equals_7 = Objects.equal(tr, "double");
      _and_3 = _equals_7;
    }
    if (_and_3) {
      this.error("Tipos incompativeis, De double para short", 
        AnsicPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION);
    }
    boolean _and_4 = false;
    boolean _equals_8 = Objects.equal(tl, "long");
    if (!_equals_8) {
      _and_4 = false;
    } else {
      boolean _equals_9 = Objects.equal(tr, "float");
      _and_4 = _equals_9;
    }
    if (_and_4) {
      this.error("Tipos incompativeis, De float para long", 
        AnsicPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION);
    }
    boolean _and_5 = false;
    boolean _equals_10 = Objects.equal(tl, "long");
    if (!_equals_10) {
      _and_5 = false;
    } else {
      boolean _equals_11 = Objects.equal(tr, "double");
      _and_5 = _equals_11;
    }
    if (_and_5) {
      this.error("Tipos incompativeis, De double para long", 
        AnsicPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION);
    }
    boolean _and_6 = false;
    boolean _equals_12 = Objects.equal(tl, "int");
    if (!_equals_12) {
      _and_6 = false;
    } else {
      boolean _equals_13 = Objects.equal(tr, "long");
      _and_6 = _equals_13;
    }
    if (_and_6) {
      this.error("Tipos incompativeis, De int para long", 
        AnsicPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION);
    }
    boolean _and_7 = false;
    boolean _equals_14 = Objects.equal(tl, "signed");
    if (!_equals_14) {
      _and_7 = false;
    } else {
      boolean _equals_15 = Objects.equal(tr, "unsigned");
      _and_7 = _equals_15;
    }
    if (_and_7) {
      this.error("Tipos unsigned, De long para signed", 
        AnsicPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION);
    }
    boolean _and_8 = false;
    boolean _equals_16 = Objects.equal(tl, "unsigned");
    if (!_equals_16) {
      _and_8 = false;
    } else {
      boolean _equals_17 = Objects.equal(tr, "signed");
      _and_8 = _equals_17;
    }
    if (_and_8) {
      this.error("Tipos incompativeis, De unsigned para signed", 
        AnsicPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION);
    }
  }
  
  @Check
  public AnsicValidator.Function checkFunctionDefinition(final function_definition func_decl) {
    AnsicValidator.Function _xblockexpression = null;
    {
      AnsicValidator.Function f = new AnsicValidator.Function();
      AnsicValidator.Function _xifexpression = null;
      declarator _declarator = func_decl.getDeclarator();
      direct_declarator _direct_declarator = _declarator.getDirect_declarator();
      direct_declarator_linha _direct_declarator_linha = _direct_declarator.getDirect_declarator_linha();
      direct_declarator_complemento _direct_declarator_complemento = _direct_declarator_linha.getDirect_declarator_complemento();
      boolean _equals = Objects.equal(_direct_declarator_complemento, null);
      if (_equals) {
        AnsicValidator.Function _xblockexpression_1 = null;
        {
          EList<declaration_specifiers> _declaration_specifiers = func_decl.getDeclaration_specifiers();
          declaration_specifiers _get = _declaration_specifiers.get(0);
          type_specifier _type_specifier = _get.getType_specifier();
          String _type_name_str = _type_specifier.getType_name_str();
          f.retType = _type_name_str;
          declarator _declarator_1 = func_decl.getDeclarator();
          direct_declarator _direct_declarator_1 = _declarator_1.getDirect_declarator();
          String _identifier = _direct_declarator_1.getIdentifier();
          String _string = _identifier.toString();
          f.name = _string;
          f.param_number = 0;
          InputOutput.<String>println((("Inserting function... " + f.name) + "With 0 params"));
          _xblockexpression_1 = this.functions.put(f.name, f);
        }
        _xifexpression = _xblockexpression_1;
      } else {
        AnsicValidator.Function _xblockexpression_2 = null;
        {
          EList<declaration_specifiers> _declaration_specifiers = func_decl.getDeclaration_specifiers();
          declaration_specifiers _get = _declaration_specifiers.get(0);
          type_specifier _type_specifier = _get.getType_specifier();
          String _type_name_str = _type_specifier.getType_name_str();
          f.retType = _type_name_str;
          declarator _declarator_1 = func_decl.getDeclarator();
          direct_declarator _direct_declarator_1 = _declarator_1.getDirect_declarator();
          String _identifier = _direct_declarator_1.getIdentifier();
          String _string = _identifier.toString();
          f.name = _string;
          declarator _declarator_2 = func_decl.getDeclarator();
          direct_declarator _direct_declarator_2 = _declarator_2.getDirect_declarator();
          direct_declarator_linha _direct_declarator_linha_1 = _direct_declarator_2.getDirect_declarator_linha();
          direct_declarator_complemento _direct_declarator_complemento_1 = _direct_declarator_linha_1.getDirect_declarator_complemento();
          parameter_type_list _parameter_type_list = _direct_declarator_complemento_1.getParameter_type_list();
          parameter_lista _parameter_lista = _parameter_type_list.getParameter_lista();
          EList<parameter_declaration> params = _parameter_lista.getParameter_declarations();
          int _size = params.size();
          f.param_number = _size;
          for (int i = 0; (i < f.param_number); i++) {
            {
              parameter_declaration decl = params.get(i);
              declaration_specifiers _declaration_specifiers_1 = decl.getDeclaration_specifiers();
              type_specifier _type_specifier_1 = _declaration_specifiers_1.getType_specifier();
              String _type_name_str_1 = _type_specifier_1.getType_name_str();
              f.params_types.add(_type_name_str_1);
            }
          }
          InputOutput.<String>println((((("Inserting function... " + f.name) + "with ") + Integer.valueOf(f.param_number)) + " params"));
          _xblockexpression_2 = this.functions.put(f.name, f);
        }
        _xifexpression = _xblockexpression_2;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  @Check
  public compound_statement checkSwitch(final selection_statement sel_stmt) {
    compound_statement _xblockexpression = null;
    {
      expression _expression = sel_stmt.getExpression();
      assignment_expression _assignment_expression = _expression.getAssignment_expression();
      assignment_expression _assignment_expression_1 = _assignment_expression.getAssignment_expression();
      conditional_expression _conditional_expression = _assignment_expression_1.getConditional_expression();
      logical_or_expression _logical_or_expression = _conditional_expression.getLogical_or_expression();
      logical_and_expression _logical_and_expression = _logical_or_expression.getLogical_and_expression();
      inclusive_or_expression _inclusive_or_expression = _logical_and_expression.getInclusive_or_expression();
      exclusive_or_expression _exclusive_or_expression = _inclusive_or_expression.getExclusive_or_expression();
      and_expression _and_expression = _exclusive_or_expression.getAnd_expression();
      equality_expression _equality_expression = _and_expression.getEquality_expression();
      relational_expression _relational_expression = _equality_expression.getRelational_expression();
      shift_expression _shift_expression = _relational_expression.getShift_expression();
      additive_expression _additive_expression = _shift_expression.getAdditive_expression();
      multiplicative_expression _multiplicative_expression = _additive_expression.getMultiplicative_expression();
      cast_expression _cast_expression = _multiplicative_expression.getCast_expression();
      unary_expression _unary_expression = _cast_expression.getUnary_expression();
      postfix_expression _postfix_expression = _unary_expression.getPostfix_expression();
      primary_expression _primary_expression = _postfix_expression.getPrimary_expression();
      String id = _primary_expression.getIdentifier();
      Set<String> _keySet = this.variables.keySet();
      boolean _contains = _keySet.contains(id);
      if (_contains) {
        this.error("Variavel não declarada", AnsicPackage.Literals.SELECTION_STATEMENT__EXPRESSION);
      }
      statement _statement = sel_stmt.getStatement();
      _xblockexpression = _statement.getCompound_statement();
    }
    return _xblockexpression;
  }
}
