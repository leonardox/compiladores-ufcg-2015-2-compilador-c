/**
 * generated by Xtext 2.9.1
 */
package org.xtext.example.validation;

import com.google.common.base.Objects;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.ExclusiveRange;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.xtext.example.ansic.AnsicPackage;
import org.xtext.example.ansic.DomainModel;
import org.xtext.example.ansic.PostFixEmpryParams;
import org.xtext.example.ansic.additive_expression;
import org.xtext.example.ansic.and_expression;
import org.xtext.example.ansic.argument_expression_list;
import org.xtext.example.ansic.assignment_expression;
import org.xtext.example.ansic.cast_expression;
import org.xtext.example.ansic.compound_statement;
import org.xtext.example.ansic.conditional_expression;
import org.xtext.example.ansic.constant;
import org.xtext.example.ansic.declaration;
import org.xtext.example.ansic.declaration_specifiers;
import org.xtext.example.ansic.declarator;
import org.xtext.example.ansic.direct_declarator;
import org.xtext.example.ansic.direct_declarator_complemento;
import org.xtext.example.ansic.direct_declarator_linha;
import org.xtext.example.ansic.enum_specifier;
import org.xtext.example.ansic.equality_expression;
import org.xtext.example.ansic.exclusive_or_expression;
import org.xtext.example.ansic.expression;
import org.xtext.example.ansic.function_definition;
import org.xtext.example.ansic.inclusive_or_expression;
import org.xtext.example.ansic.init_declarator;
import org.xtext.example.ansic.init_declarator_list;
import org.xtext.example.ansic.initializer;
import org.xtext.example.ansic.logical_and_expression;
import org.xtext.example.ansic.logical_or_expression;
import org.xtext.example.ansic.multiplicative_expression;
import org.xtext.example.ansic.parameter_declaration;
import org.xtext.example.ansic.parameter_lista;
import org.xtext.example.ansic.parameter_type_list;
import org.xtext.example.ansic.postfix_expression;
import org.xtext.example.ansic.postfix_expression_complement;
import org.xtext.example.ansic.postfix_expression_linha;
import org.xtext.example.ansic.primary_expression;
import org.xtext.example.ansic.relational_expression;
import org.xtext.example.ansic.selection_statement;
import org.xtext.example.ansic.shift_expression;
import org.xtext.example.ansic.statement;
import org.xtext.example.ansic.type_specifier;
import org.xtext.example.ansic.unary_expression;
import org.xtext.example.validation.AbstractAnsicValidator;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class AnsicValidator extends AbstractAnsicValidator {
  public static class Function {
    public int param_number = 0;
    
    public List<String> params_types = new ArrayList<String>();
    
    public String retType;
    
    public String name;
  }
  
  public final static String INVALID_NAME = "invalidName";
  
  private HashMap<String, String> variables = CollectionLiterals.<String, String>newHashMap();
  
  private HashMap<String, AnsicValidator.Function> functions = CollectionLiterals.<String, AnsicValidator.Function>newHashMap();
  
  @Check
  public void restart(final DomainModel d) {
    InputOutput.<String>println("Clearing...");
    this.variables.clear();
    this.functions.clear();
  }
  
  public void checkDeclarationWithConstant(final String leftType, final primary_expression rightType) {
    boolean _and = false;
    boolean _and_1 = false;
    constant _constant = rightType.getConstant();
    String _f_constant = _constant.getF_constant();
    boolean _equals = Objects.equal(_f_constant, null);
    if (!_equals) {
      _and_1 = false;
    } else {
      constant _constant_1 = rightType.getConstant();
      String _enumz = _constant_1.getEnumz();
      boolean _equals_1 = Objects.equal(_enumz, null);
      _and_1 = _equals_1;
    }
    if (!_and_1) {
      _and = false;
    } else {
      constant _constant_2 = rightType.getConstant();
      String _char = _constant_2.getChar();
      boolean _equals_2 = Objects.equal(_char, null);
      _and = _equals_2;
    }
    if (_and) {
      boolean _or = false;
      boolean _or_1 = false;
      boolean _equals_3 = Objects.equal(leftType, "char");
      if (_equals_3) {
        _or_1 = true;
      } else {
        boolean _equals_4 = Objects.equal(leftType, "bool");
        _or_1 = _equals_4;
      }
      if (_or_1) {
        _or = true;
      } else {
        boolean _equals_5 = Objects.equal(leftType, "void");
        _or = _equals_5;
      }
      if (_or) {
        this.error("Esse tipo não recebe valores numéricos", 
          AnsicPackage.Literals.DECLARATION__DECLARATION_SPECIFIERS);
      }
    } else {
      constant _constant_3 = rightType.getConstant();
      String _f_constant_1 = _constant_3.getF_constant();
      boolean _notEquals = (!Objects.equal(_f_constant_1, null));
      if (_notEquals) {
        boolean _or_2 = false;
        boolean _or_3 = false;
        boolean _or_4 = false;
        boolean _equals_6 = Objects.equal(leftType, "char");
        if (_equals_6) {
          _or_4 = true;
        } else {
          boolean _equals_7 = Objects.equal(leftType, "bool");
          _or_4 = _equals_7;
        }
        if (_or_4) {
          _or_3 = true;
        } else {
          boolean _equals_8 = Objects.equal(leftType, "void");
          _or_3 = _equals_8;
        }
        if (_or_3) {
          _or_2 = true;
        } else {
          boolean _equals_9 = Objects.equal(leftType, "int");
          _or_2 = _equals_9;
        }
        if (_or_2) {
          this.error("Esse tipo não recebe valores numéricos com ponto flutuante", 
            AnsicPackage.Literals.DECLARATION__INIT_DECLARATOR_LIST);
        }
      }
    }
  }
  
  @Check
  public void checkForEmptyParamFunc(final PostFixEmpryParams call) {
    EObject _eContainer = call.eContainer();
    EObject _eContainer_1 = _eContainer.eContainer();
    postfix_expression parent = ((postfix_expression) _eContainer_1);
    primary_expression _primary_expression = parent.getPrimary_expression();
    String name = _primary_expression.getIdentifier();
    boolean _containsKey = this.functions.containsKey(name);
    boolean _not = (!_containsKey);
    if (_not) {
      this.error("Função não definida", 
        null);
    } else {
      AnsicValidator.Function func = this.functions.get(name);
      if ((func.param_number != 0)) {
        this.error("Numero de parametros incompativeis", 
          null);
      }
    }
  }
  
  @Check
  public void checkFunctionCall(final postfix_expression_complement call) {
    EObject _eContainer = call.eContainer();
    EObject _eContainer_1 = _eContainer.eContainer();
    postfix_expression parent = ((postfix_expression) _eContainer_1);
    primary_expression _primary_expression = parent.getPrimary_expression();
    String name = _primary_expression.getIdentifier();
    boolean _containsKey = this.functions.containsKey(name);
    boolean _not = (!_containsKey);
    if (_not) {
      this.error("Função não definida", 
        null);
    } else {
      AnsicValidator.Function func = this.functions.get(name);
      InputOutput.<String>println((((("Checking params for: " + func.name) + " With: ") + Integer.valueOf(func.param_number)) + " params."));
      argument_expression_list _argument_expression_list = call.getArgument_expression_list();
      EList<assignment_expression> _assignment_expressions = _argument_expression_list.getAssignment_expressions();
      int _size = _assignment_expressions.size();
      boolean _notEquals = (func.param_number != _size);
      if (_notEquals) {
        this.error("Numero de parametros incompativeis", 
          AnsicPackage.Literals.POSTFIX_EXPRESSION_COMPLEMENT__ARGUMENT_EXPRESSION_LIST);
      } else {
        argument_expression_list _argument_expression_list_1 = call.getArgument_expression_list();
        EList<assignment_expression> _assignment_expressions_1 = _argument_expression_list_1.getAssignment_expressions();
        int _size_1 = _assignment_expressions_1.size();
        ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _size_1, true);
        for (final Integer i : _doubleDotLessThan) {
        }
      }
    }
  }
  
  @Check
  public String checkDeclarationTypes(final declaration decl) {
    String _xblockexpression = null;
    {
      EList<declaration_specifiers> _declaration_specifiers = decl.getDeclaration_specifiers();
      declaration_specifiers _get = _declaration_specifiers.get(0);
      type_specifier _type_specifier = _get.getType_specifier();
      String leftType = _type_specifier.getType_name_str();
      EList<init_declarator_list> _init_declarator_list = decl.getInit_declarator_list();
      init_declarator_list _get_1 = _init_declarator_list.get(0);
      init_declarator _init_declarator = _get_1.getInit_declarator();
      declarator _declarator = _init_declarator.getDeclarator();
      direct_declarator _direct_declarator = _declarator.getDirect_declarator();
      String id = _direct_declarator.getIdentifier();
      EList<init_declarator_list> _init_declarator_list_1 = decl.getInit_declarator_list();
      init_declarator_list _get_2 = _init_declarator_list_1.get(0);
      init_declarator _init_declarator_1 = _get_2.getInit_declarator();
      initializer _initializer = _init_declarator_1.getInitializer();
      assignment_expression _assignment_expression = _initializer.getAssignment_expression();
      conditional_expression _conditional_expression = _assignment_expression.getConditional_expression();
      logical_or_expression _logical_or_expression = _conditional_expression.getLogical_or_expression();
      logical_and_expression _logical_and_expression = _logical_or_expression.getLogical_and_expression();
      inclusive_or_expression _inclusive_or_expression = _logical_and_expression.getInclusive_or_expression();
      exclusive_or_expression _exclusive_or_expression = _inclusive_or_expression.getExclusive_or_expression();
      and_expression _and_expression = _exclusive_or_expression.getAnd_expression();
      equality_expression _equality_expression = _and_expression.getEquality_expression();
      relational_expression _relational_expression = _equality_expression.getRelational_expression();
      shift_expression _shift_expression = _relational_expression.getShift_expression();
      additive_expression _additive_expression = _shift_expression.getAdditive_expression();
      multiplicative_expression _multiplicative_expression = _additive_expression.getMultiplicative_expression();
      cast_expression _cast_expression = _multiplicative_expression.getCast_expression();
      unary_expression _unary_expression = _cast_expression.getUnary_expression();
      postfix_expression _postfix_expression = _unary_expression.getPostfix_expression();
      primary_expression rightType = _postfix_expression.getPrimary_expression();
      constant _constant = rightType.getConstant();
      boolean _notEquals = (!Objects.equal(_constant, null));
      if (_notEquals) {
        this.checkDeclarationWithConstant(leftType, rightType);
      } else {
        boolean _and = false;
        String _identifier = rightType.getIdentifier();
        boolean _notEquals_1 = (!Objects.equal(_identifier, null));
        if (!_notEquals_1) {
          _and = false;
        } else {
          String _identifier_1 = rightType.getIdentifier();
          String _trim = _identifier_1.trim();
          boolean _isEmpty = _trim.isEmpty();
          boolean _not = (!_isEmpty);
          _and = _not;
        }
        if (_and) {
          String _identifier_2 = rightType.getIdentifier();
          boolean _containsKey = this.variables.containsKey(_identifier_2);
          if (_containsKey) {
            String _identifier_3 = rightType.getIdentifier();
            String rType = this.variables.get(_identifier_3);
            boolean _and_1 = false;
            boolean _equals = Objects.equal(leftType, "enum");
            if (!_equals) {
              _and_1 = false;
            } else {
              boolean _notEquals_2 = (!Objects.equal(rightType, "enum"));
              _and_1 = _notEquals_2;
            }
            if (_and_1) {
              this.error("A variavel deve ser um enum", 
                AnsicPackage.Literals.DECLARATION__INIT_DECLARATOR_LIST);
            }
          } else {
            this.error("Variavel não declarada", 
              AnsicPackage.Literals.DECLARATION__INIT_DECLARATOR_LIST);
          }
        } else {
          expression _expression = rightType.getExpression();
          boolean _notEquals_3 = (!Objects.equal(_expression, null));
          if (_notEquals_3) {
          }
        }
      }
      String _xifexpression = null;
      boolean _containsKey_1 = this.variables.containsKey(id);
      if (_containsKey_1) {
        this.error("Variável já declarada", null);
      } else {
        _xifexpression = this.variables.put(id, leftType);
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  public void validateActribWithId(final String idLeft, final String idRight) {
    Set<String> _keySet = this.variables.keySet();
    boolean _contains = _keySet.contains(idRight);
    boolean _not = (!_contains);
    if (_not) {
      this.error("Variavel não declarada", 
        AnsicPackage.Literals.ASSIGNMENT_EXPRESSION__ASSIGNMENT_EXPRESSION);
    }
    String tr = this.variables.get(idRight);
    String tl = this.variables.get(idLeft);
    this.validateAlarg(tr, tl);
  }
  
  @Check
  public String checkEnumValid(final enum_specifier enumz) {
    String _xifexpression = null;
    String _identifier = enumz.getIdentifier();
    boolean _notEquals = (!Objects.equal(_identifier, null));
    if (_notEquals) {
      String _xifexpression_1 = null;
      String _identifier_1 = enumz.getIdentifier();
      boolean _containsKey = this.variables.containsKey(_identifier_1);
      if (_containsKey) {
        this.error("Variável já declarada", 
          AnsicPackage.Literals.ENUM_SPECIFIER__IDENTIFIER);
      } else {
        String _identifier_2 = enumz.getIdentifier();
        _xifexpression_1 = this.variables.put(_identifier_2, "enum");
      }
      _xifexpression = _xifexpression_1;
    }
    return _xifexpression;
  }
  
  @Check
  public void checkAtribType(final assignment_expression asexp) {
    unary_expression _unary_expression = asexp.getUnary_expression();
    postfix_expression _postfix_expression = _unary_expression.getPostfix_expression();
    primary_expression _primary_expression = _postfix_expression.getPrimary_expression();
    String idLeft = _primary_expression.getIdentifier();
    Set<String> _keySet = this.variables.keySet();
    boolean _contains = _keySet.contains(idLeft);
    boolean _not = (!_contains);
    if (_not) {
      this.error("Variavel não declarada", 
        AnsicPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION);
    }
    assignment_expression _assignment_expression = asexp.getAssignment_expression();
    conditional_expression _conditional_expression = _assignment_expression.getConditional_expression();
    logical_or_expression _logical_or_expression = _conditional_expression.getLogical_or_expression();
    logical_and_expression _logical_and_expression = _logical_or_expression.getLogical_and_expression();
    inclusive_or_expression _inclusive_or_expression = _logical_and_expression.getInclusive_or_expression();
    exclusive_or_expression _exclusive_or_expression = _inclusive_or_expression.getExclusive_or_expression();
    and_expression _and_expression = _exclusive_or_expression.getAnd_expression();
    equality_expression _equality_expression = _and_expression.getEquality_expression();
    relational_expression _relational_expression = _equality_expression.getRelational_expression();
    shift_expression _shift_expression = _relational_expression.getShift_expression();
    additive_expression _additive_expression = _shift_expression.getAdditive_expression();
    multiplicative_expression _multiplicative_expression = _additive_expression.getMultiplicative_expression();
    cast_expression _cast_expression = _multiplicative_expression.getCast_expression();
    unary_expression _unary_expression_1 = _cast_expression.getUnary_expression();
    postfix_expression _postfix_expression_1 = _unary_expression_1.getPostfix_expression();
    primary_expression idRight = _postfix_expression_1.getPrimary_expression();
    assignment_expression _assignment_expression_1 = asexp.getAssignment_expression();
    boolean _notEquals = (!Objects.equal(_assignment_expression_1, null));
    if (_notEquals) {
      boolean _and = false;
      String _identifier = idRight.getIdentifier();
      boolean _notEquals_1 = (!Objects.equal(_identifier, null));
      if (!_notEquals_1) {
        _and = false;
      } else {
        String _identifier_1 = idRight.getIdentifier();
        String _trim = _identifier_1.trim();
        boolean _isEmpty = _trim.isEmpty();
        boolean _not_1 = (!_isEmpty);
        _and = _not_1;
      }
      if (_and) {
        String _identifier_2 = idRight.getIdentifier();
        this.validateActribWithId(idLeft, _identifier_2);
      } else {
        constant _constant = idRight.getConstant();
        boolean _notEquals_2 = (!Objects.equal(_constant, null));
        if (_notEquals_2) {
          String left_type = this.variables.get(idLeft);
          this.checkDeclarationWithConstant(left_type, idRight);
        } else {
          expression _expression = idRight.getExpression();
          boolean _notEquals_3 = (!Objects.equal(_expression, null));
          if (_notEquals_3) {
          }
        }
      }
    }
    assignment_expression _assignment_expression_2 = asexp.getAssignment_expression();
    conditional_expression _conditional_expression_1 = _assignment_expression_2.getConditional_expression();
    logical_or_expression _logical_or_expression_1 = _conditional_expression_1.getLogical_or_expression();
    logical_and_expression _logical_and_expression_1 = _logical_or_expression_1.getLogical_and_expression();
    inclusive_or_expression _inclusive_or_expression_1 = _logical_and_expression_1.getInclusive_or_expression();
    exclusive_or_expression _exclusive_or_expression_1 = _inclusive_or_expression_1.getExclusive_or_expression();
    and_expression _and_expression_1 = _exclusive_or_expression_1.getAnd_expression();
    equality_expression _equality_expression_1 = _and_expression_1.getEquality_expression();
    relational_expression _relational_expression_1 = _equality_expression_1.getRelational_expression();
    shift_expression _shift_expression_1 = _relational_expression_1.getShift_expression();
    additive_expression _additive_expression_1 = _shift_expression_1.getAdditive_expression();
    multiplicative_expression _multiplicative_expression_1 = _additive_expression_1.getMultiplicative_expression();
    cast_expression _cast_expression_1 = _multiplicative_expression_1.getCast_expression();
    unary_expression _unary_expression_2 = _cast_expression_1.getUnary_expression();
    postfix_expression _postfix_expression_2 = _unary_expression_2.getPostfix_expression();
    postfix_expression_linha mthodCall = _postfix_expression_2.getPostfix_expression_linha();
  }
  
  public void validateAlarg(final String tr, final String tl) {
    boolean _and = false;
    boolean _equals = Objects.equal(tl, "int");
    if (!_equals) {
      _and = false;
    } else {
      boolean _equals_1 = Objects.equal(tr, "float");
      _and = _equals_1;
    }
    if (_and) {
      this.error("Tipos incompativeis, De float para int", 
        AnsicPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION);
    }
    boolean _and_1 = false;
    boolean _equals_2 = Objects.equal(tl, "int");
    if (!_equals_2) {
      _and_1 = false;
    } else {
      boolean _equals_3 = Objects.equal(tr, "double");
      _and_1 = _equals_3;
    }
    if (_and_1) {
      this.error("Tipos incompativeis, De double para int", 
        AnsicPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION);
    }
    boolean _and_2 = false;
    boolean _equals_4 = Objects.equal(tl, "short");
    if (!_equals_4) {
      _and_2 = false;
    } else {
      boolean _equals_5 = Objects.equal(tr, "float");
      _and_2 = _equals_5;
    }
    if (_and_2) {
      this.error("Tipos incompativeis, De float para short", 
        AnsicPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION);
    }
    boolean _and_3 = false;
    boolean _equals_6 = Objects.equal(tl, "short");
    if (!_equals_6) {
      _and_3 = false;
    } else {
      boolean _equals_7 = Objects.equal(tr, "double");
      _and_3 = _equals_7;
    }
    if (_and_3) {
      this.error("Tipos incompativeis, De double para short", 
        AnsicPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION);
    }
    boolean _and_4 = false;
    boolean _equals_8 = Objects.equal(tl, "long");
    if (!_equals_8) {
      _and_4 = false;
    } else {
      boolean _equals_9 = Objects.equal(tr, "float");
      _and_4 = _equals_9;
    }
    if (_and_4) {
      this.error("Tipos incompativeis, De float para long", 
        AnsicPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION);
    }
    boolean _and_5 = false;
    boolean _equals_10 = Objects.equal(tl, "long");
    if (!_equals_10) {
      _and_5 = false;
    } else {
      boolean _equals_11 = Objects.equal(tr, "double");
      _and_5 = _equals_11;
    }
    if (_and_5) {
      this.error("Tipos incompativeis, De double para long", 
        AnsicPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION);
    }
    boolean _and_6 = false;
    boolean _equals_12 = Objects.equal(tl, "int");
    if (!_equals_12) {
      _and_6 = false;
    } else {
      boolean _equals_13 = Objects.equal(tr, "long");
      _and_6 = _equals_13;
    }
    if (_and_6) {
      this.error("Tipos incompativeis, De int para long", 
        AnsicPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION);
    }
    boolean _and_7 = false;
    boolean _equals_14 = Objects.equal(tl, "signed");
    if (!_equals_14) {
      _and_7 = false;
    } else {
      boolean _equals_15 = Objects.equal(tr, "unsigned");
      _and_7 = _equals_15;
    }
    if (_and_7) {
      this.error("Tipos unsigned, De long para signed", 
        AnsicPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION);
    }
    boolean _and_8 = false;
    boolean _equals_16 = Objects.equal(tl, "unsigned");
    if (!_equals_16) {
      _and_8 = false;
    } else {
      boolean _equals_17 = Objects.equal(tr, "signed");
      _and_8 = _equals_17;
    }
    if (_and_8) {
      this.error("Tipos incompativeis, De unsigned para signed", 
        AnsicPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION);
    }
  }
  
  @Check
  public AnsicValidator.Function checkFunctionDefinition(final function_definition func_decl) {
    AnsicValidator.Function _xblockexpression = null;
    {
      AnsicValidator.Function f = new AnsicValidator.Function();
      InputOutput.<String>println("Creating function...");
      AnsicValidator.Function _xifexpression = null;
      declarator _declarator = func_decl.getDeclarator();
      direct_declarator _direct_declarator = _declarator.getDirect_declarator();
      direct_declarator_linha _direct_declarator_linha = _direct_declarator.getDirect_declarator_linha();
      direct_declarator_complemento _direct_declarator_complemento = _direct_declarator_linha.getDirect_declarator_complemento();
      parameter_type_list _parameter_type_list = _direct_declarator_complemento.getParameter_type_list();
      boolean _equals = Objects.equal(_parameter_type_list, null);
      if (_equals) {
        AnsicValidator.Function _xblockexpression_1 = null;
        {
          EList<declaration_specifiers> _declaration_specifiers = func_decl.getDeclaration_specifiers();
          declaration_specifiers _get = _declaration_specifiers.get(0);
          type_specifier _type_specifier = _get.getType_specifier();
          String _type_name_str = _type_specifier.getType_name_str();
          f.retType = _type_name_str;
          declarator _declarator_1 = func_decl.getDeclarator();
          direct_declarator _direct_declarator_1 = _declarator_1.getDirect_declarator();
          String _identifier = _direct_declarator_1.getIdentifier();
          String _string = _identifier.toString();
          f.name = _string;
          f.param_number = 0;
          InputOutput.<String>println((("Inserting function... " + f.name) + "With 0 params"));
          _xblockexpression_1 = this.functions.put(f.name, f);
        }
        _xifexpression = _xblockexpression_1;
      } else {
        AnsicValidator.Function _xblockexpression_2 = null;
        {
          EList<declaration_specifiers> _declaration_specifiers = func_decl.getDeclaration_specifiers();
          declaration_specifiers _get = _declaration_specifiers.get(0);
          type_specifier _type_specifier = _get.getType_specifier();
          String _type_name_str = _type_specifier.getType_name_str();
          f.retType = _type_name_str;
          declarator _declarator_1 = func_decl.getDeclarator();
          direct_declarator _direct_declarator_1 = _declarator_1.getDirect_declarator();
          String _identifier = _direct_declarator_1.getIdentifier();
          String _string = _identifier.toString();
          f.name = _string;
          declarator _declarator_2 = func_decl.getDeclarator();
          direct_declarator _direct_declarator_2 = _declarator_2.getDirect_declarator();
          direct_declarator_linha _direct_declarator_linha_1 = _direct_declarator_2.getDirect_declarator_linha();
          direct_declarator_complemento _direct_declarator_complemento_1 = _direct_declarator_linha_1.getDirect_declarator_complemento();
          parameter_type_list _parameter_type_list_1 = _direct_declarator_complemento_1.getParameter_type_list();
          parameter_lista _parameter_lista = _parameter_type_list_1.getParameter_lista();
          EList<parameter_declaration> params = _parameter_lista.getParameter_declarations();
          int _size = params.size();
          f.param_number = _size;
          for (int i = 0; (i < f.param_number); i++) {
            {
              parameter_declaration decl = params.get(i);
              declaration_specifiers _declaration_specifiers_1 = decl.getDeclaration_specifiers();
              type_specifier _type_specifier_1 = _declaration_specifiers_1.getType_specifier();
              String _type_name_str_1 = _type_specifier_1.getType_name_str();
              f.params_types.add(_type_name_str_1);
            }
          }
          InputOutput.<String>println((((("Inserting function... " + f.name) + "with ") + Integer.valueOf(f.param_number)) + " params"));
          _xblockexpression_2 = this.functions.put(f.name, f);
        }
        _xifexpression = _xblockexpression_2;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  @Check
  public compound_statement checkSwitch(final selection_statement sel_stmt) {
    compound_statement _xblockexpression = null;
    {
      expression _expression = sel_stmt.getExpression();
      assignment_expression _assignment_expression = _expression.getAssignment_expression();
      assignment_expression _assignment_expression_1 = _assignment_expression.getAssignment_expression();
      conditional_expression _conditional_expression = _assignment_expression_1.getConditional_expression();
      logical_or_expression _logical_or_expression = _conditional_expression.getLogical_or_expression();
      logical_and_expression _logical_and_expression = _logical_or_expression.getLogical_and_expression();
      inclusive_or_expression _inclusive_or_expression = _logical_and_expression.getInclusive_or_expression();
      exclusive_or_expression _exclusive_or_expression = _inclusive_or_expression.getExclusive_or_expression();
      and_expression _and_expression = _exclusive_or_expression.getAnd_expression();
      equality_expression _equality_expression = _and_expression.getEquality_expression();
      relational_expression _relational_expression = _equality_expression.getRelational_expression();
      shift_expression _shift_expression = _relational_expression.getShift_expression();
      additive_expression _additive_expression = _shift_expression.getAdditive_expression();
      multiplicative_expression _multiplicative_expression = _additive_expression.getMultiplicative_expression();
      cast_expression _cast_expression = _multiplicative_expression.getCast_expression();
      unary_expression _unary_expression = _cast_expression.getUnary_expression();
      postfix_expression _postfix_expression = _unary_expression.getPostfix_expression();
      primary_expression _primary_expression = _postfix_expression.getPrimary_expression();
      String id = _primary_expression.getIdentifier();
      Set<String> _keySet = this.variables.keySet();
      boolean _contains = _keySet.contains(id);
      if (_contains) {
        this.error("Variavel não declarada", AnsicPackage.Literals.SELECTION_STATEMENT__EXPRESSION);
      }
      statement _statement = sel_stmt.getStatement();
      _xblockexpression = _statement.getCompound_statement();
    }
    return _xblockexpression;
  }
}
