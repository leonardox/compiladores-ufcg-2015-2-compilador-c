/*
 * generated by Xtext 2.9.1
 */
package org.xtext.example.validation

import org.eclipse.xtext.validation.Check
import org.xtext.example.ansic.type_specifier
import org.xtext.example.ansic.DomainModel
import org.xtext.example.ansic.postfix_expression
import org.xtext.example.ansic.postfix_expression_complement
import org.xtext.example.ansic.translation_unit
import org.xtext.example.ansic.unary_expression
import org.xtext.example.ansic.cast_expression
import org.xtext.example.ansic.multiplicative_expression
import org.xtext.example.ansic.multiplicative_expression_linha	

import org.xtext.example.ansic.multiplicative_expression_complement
import org.xtext.example.ansic.additive_expression
import org.xtext.example.ansic.additive_expression_linha
import org.xtext.example.ansic.additive_expression_complement
import org.xtext.example.ansic.shift_expression
import org.xtext.example.ansic.shift_expression_linha
import org.xtext.example.ansic.shift_expression_complement
import org.xtext.example.ansic.relational_expression
import org.xtext.example.ansic.relational_expression_linha
import org.xtext.example.ansic.relational_expression_complement
import org.xtext.example.ansic.equality_expression
import org.xtext.example.ansic.equality_expression_linha
import org.xtext.example.ansic.equality_expression_complement
import org.xtext.example.ansic.additive_expression
import org.xtext.example.ansic.PostFixEmpryParams
import org.xtext.example.ansic.enum_specifier
import org.xtext.example.ansic.declaration
import org.xtext.example.ansic.primary_expression
import org.xtext.example.ansic.assignment_expression
import org.xtext.example.ansic.function_definition
import org.xtext.example.ansic.selection_statement
import org.xtext.example.ansic.AnsicPackage
import java.util.List
import java.util.ArrayList
import org.xtext.example.ansic.AnsicFactory
import org.xtext.example.ansic.impl.AnsicFactoryImpl

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class AnsicValidator extends AbstractAnsicValidator {
	
  public static val INVALID_NAME = 'invalidName'
  private var variables = <String,String>newHashMap();
  public enum ExpRetType {
  	NUMERIC,
  	CHAR,
  	BOOL
  }
  public static class Function{
  		public int param_number = 0;
  		public List<String> params_types = new ArrayList<String>();
  		public String retType;
  		public String name;
  }
  private var functions = <String, Function>newHashMap();


	@Check
	def restart(DomainModel d){
		println("Clearing...")
		variables.clear();
		functions.clear();
	}

	def checkDeclarationWithConstant(String leftType, primary_expression rightType){
		if(rightType.constant.f_constant == null && rightType.constant.enumz == null && rightType.constant.char == null){
			if(leftType == "char" || leftType == 'bool' || leftType == 'void'){
							error('Esse tipo não recebe valores numéricos', 
					AnsicPackage.Literals.DECLARATION__DECLARATION_SPECIFIERS);
			}
		}else if(rightType.constant.f_constant != null){
			if(leftType == "char" || leftType == 'bool' || leftType == 'void' || leftType == "int"){
							error('Esse tipo não recebe valores numéricos com ponto flutuante', 
					AnsicPackage.Literals.DECLARATION__INIT_DECLARATOR_LIST);
			}
		}
	}
	
	@Check
	def checkForEmptyParamFunc(PostFixEmpryParams call){
		var parent = call.eContainer().eContainer() as postfix_expression;
		var name = parent.primary_expression.identifier;
		if(!functions.containsKey(name)){
			error("Função não definida",
				null
			)
		}else{
			var func = functions.get(name);
			if(func.param_number != 0){
				error("Numero de parametros incompativeis",
					null
				)
			}
		}
	}
	
	def primaryExpFromAssigExp(assignment_expression exp){
		var ret = exp.conditional_expression.
		logical_or_expression.logical_and_expression.inclusive_or_expression.exclusive_or_expression.
		and_expression.equality_expression.relational_expression.shift_expression.additive_expression.
		multiplicative_expression.cast_expression.unary_expression.postfix_expression.primary_expression;
		return ret;
	}
	def t(){
		if(true){
			return 3
		}else{
			return "oia"
		}
	}
	
	def getExpType(assignment_expression exp){
		var current = exp.conditional_expression;
		if(current.conditional_expression_linha != null){
			return ExpRetType.BOOL;
		}
		var current2 = current.logical_or_expression;
		if(current2.logical_or_expression_linha != null){
			return ExpRetType.BOOL;
		}
		var current3 = current2.logical_and_expression;
		if(current3.logical_and_expression_linha != null){
			return ExpRetType.BOOL;
		}
		var current4 = current3.inclusive_or_expression;
		if(current4.inclusive_or_expression_linha != null){
			return ExpRetType.BOOL;
		}
		var current5 = current4.exclusive_or_expression;
		if(current5.exclusive_or_expression_linha != null){
			return ExpRetType.BOOL;
		}
		var current6 = current5.and_expression;
		if(current6.and_expression_linha != null){
			return ExpRetType.BOOL;
		}
		var current7 = current6.equality_expression;
		if(current7.equality_expression_linha != null){
			return ExpRetType.BOOL;
		}
		var current8 = current7.relational_expression;
		if(current8.relational_expression_linha != null){
			return ExpRetType.BOOL;
		}
		return ExpRetType.NUMERIC;
	}
	
	def evaluateExp(primary_expression primatyExp){
		if(primatyExp.expression == null){
			if(primatyExp.identifier != null && !primatyExp.identifier.trim().isEmpty()){
				if(!variables.containsKey(primatyExp.identifier)){
					error("Variavel não declarada", null);
					return ExpRetType.NUMERIC;
				}
				var varType = variables.get(primatyExp.identifier);
				if(varType.equals('char')){
					return ExpRetType.CHAR;
				}else{
					return ExpRetType.NUMERIC;
				}
			}
			if(primatyExp.constant.char != null && !primatyExp.constant.char.trim().isEmpty()){
				return ExpRetType.CHAR;
			}
			return ExpRetType.NUMERIC;
		}else{
			println("Getting type...");
			return getExpType(primatyExp.expression.assignment_expression);
		}
	}
	
	@Check
	def CheckAdditiveExp(additive_expression addExp){
		if(addExp.additive_expression_linha != null){
			var currentExp = addExp.multiplicative_expression.cast_expression.unary_expression.postfix_expression.primary_expression;
			var lType = evaluateExp(currentExp);
			if(lType == ExpRetType.BOOL){
				error("Expressão aditiva pode operar em cima deste tipo", 
					AnsicPackage.Literals.ADDITIVE_EXPRESSION__MULTIPLICATIVE_EXPRESSION
				);
			}
			
			var rSide = primaryExpFromAssigExp(addExp.additive_expression_linha.additive_expression_complement.assignment_expression);
			var rType = evaluateExp(rSide);
			if(rType == ExpRetType.BOOL){
				error("Expressão aditiva pode operar em cima deste tipo", 
					AnsicPackage.Literals.ADDITIVE_EXPRESSION__ADDITIVE_EXPRESSION_LINHA
				);
			}
			if(rType != lType){
				error("Tipos incompativeis na operação aditiva",
					null
				)
			}
		}
	}
	
	@Check
	def CheckAdditiveExp(shift_expression shiftExp){
		if(shiftExp.shift_expression_linha != null){
			var currentExp = shiftExp.additive_expression.multiplicative_expression.cast_expression.unary_expression.postfix_expression.primary_expression;
			var lType = evaluateExp(currentExp);
			if(lType == ExpRetType.BOOL){
				error("Expressão aditiva pode operar em cima deste tipo", 
					AnsicPackage.Literals.ADDITIVE_EXPRESSION__MULTIPLICATIVE_EXPRESSION
				);
			}
			
			var rSide = shiftExp.shift_expression_linha.shift_expression_complement.additive_expression.multiplicative_expression.cast_expression.unary_expression.postfix_expression.primary_expression;
			var rType = evaluateExp(rSide);
			if(rType == ExpRetType.BOOL){
				error("Expressão aditiva pode operar em cima deste tipo", 
					AnsicPackage.Literals.ADDITIVE_EXPRESSION__ADDITIVE_EXPRESSION_LINHA
				);
			}
			if(rType != lType){
				error("Tipos incompativeis na operação aditiva",
					null
				)
			}
		}
	}
	
	@Check
	def CheckAdditiveExp(multiplicative_expression mulExp){
		if(mulExp.multiplicative_expression_linha != null){
			var currentExp = mulExp.cast_expression.unary_expression.postfix_expression.primary_expression;
			var lType = evaluateExp(currentExp);
			if(lType == ExpRetType.BOOL){
				error("Expressão multiplicativa não pode operar em cima deste tipo", 
					AnsicPackage.Literals.ADDITIVE_EXPRESSION__MULTIPLICATIVE_EXPRESSION
				);
			}
			
			var rSide = primaryExpFromAssigExp(mulExp.multiplicative_expression_linha.multiplicative_expression_complement.assignment_expression);
			var rType = evaluateExp(rSide);
			if(rType == ExpRetType.BOOL){
				error("Expressão multiplicativa pode operar em cima deste tipo", 
					AnsicPackage.Literals.ADDITIVE_EXPRESSION__ADDITIVE_EXPRESSION_LINHA
				);
			}
			if(rType != lType){
				error("Tipos incompativeis na operação multiplicativa",
					null
				)
			}
		}
	}
	
	@Check
	def checkFunctionCall(postfix_expression_complement call){
		var parent = call.eContainer().eContainer() as postfix_expression;
		var name = parent.primary_expression.identifier;
		if(!functions.containsKey(name)){
			error("Função não definida",
				null
			)
		}else{
			var func = functions.get(name);
			println("Checking params for: " + func.name + " With: " + func.param_number + " params.")
			if(func.param_number != call.argument_expression_list.assignment_expressions.size()){
				error("Numero de parametros incompativeis",
					AnsicPackage.Literals.POSTFIX_EXPRESSION_COMPLEMENT__ARGUMENT_EXPRESSION_LIST
				)
			}else{
				for(i : 0 ..<call.argument_expression_list.assignment_expressions.size()){
					//Validating params
					//call.argument_expression_list.get(i)
				}
			}
		}
		
	}
	
	@Check
	def checkDeclarationTypes(declaration decl){
		var leftType =  decl.declaration_specifiers.get(0).type_specifier.type_name_str;
		var id = decl.init_declarator_list.get(0).init_declarator.declarator.direct_declarator.identifier;
		var rightType = decl.init_declarator_list.get(0).init_declarator.initializer.assignment_expression.conditional_expression.
							logical_or_expression.logical_and_expression.inclusive_or_expression.exclusive_or_expression.
							and_expression.equality_expression.relational_expression.shift_expression.additive_expression.
							multiplicative_expression.cast_expression.unary_expression.postfix_expression.primary_expression
		if(rightType.constant != null){
			//Validar quando declaração é com uma constant
			//int a = 3;
			checkDeclarationWithConstant(leftType, rightType);
		}else if (rightType.identifier != null && !rightType.identifier.trim.isEmpty()){
			if(variables.containsKey(rightType.identifier)){
				var rType = variables.get(rightType.identifier);
				if(leftType == 'enum' && rightType!='enum'){
					error("A variavel deve ser um enum",
						AnsicPackage.Literals.DECLARATION__INIT_DECLARATOR_LIST
					)
				}				
			}else{
				error("Variavel não declarada",
					AnsicPackage.Literals.DECLARATION__INIT_DECLARATOR_LIST
				)
			}
			//Validar quando é declaração que inicia com um id
			// int a = b;
		}else if (rightType.expression != null){
			//Validar quando é declaração com uma expressão
			//int a = b+c;
		}
		if(variables.containsKey(id)){
			error("Variável já declarada", null);
		}else{
			variables.put(id, leftType);
		}
		
	}
	
	def validateActribWithId(String idLeft, String idRight){
			if(!variables.keySet.contains(idRight)){
				error('Variavel não declarada',
					AnsicPackage.Literals.ASSIGNMENT_EXPRESSION__ASSIGNMENT_EXPRESSION
				);
			}			
			var tr = variables.get(idRight);
			var tl = variables.get(idLeft);		
			validateAlarg(tr,tl);
	}
	
	
	@Check 
	def checkEnumValid(enum_specifier enumz){
		if(enumz.identifier != null){
			if(variables.containsKey(enumz.identifier)){
				error("Variável já declarada", 
					AnsicPackage.Literals.ENUM_SPECIFIER__IDENTIFIER
				);
			}else{
				variables.put(enumz.identifier, 'enum');	
			}			
		}
	}
	@Check
	def checkAtribType(assignment_expression asexp){		
		var idLeft = asexp.unary_expression.postfix_expression.primary_expression.identifier;
		if(!variables.keySet.contains(idLeft)){
			error('Variavel não declarada',
				AnsicPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION
			);
		}
		var idRight = asexp.assignment_expression.conditional_expression.
		logical_or_expression.logical_and_expression.inclusive_or_expression.exclusive_or_expression.
		and_expression.equality_expression.relational_expression.shift_expression.additive_expression.
		multiplicative_expression.cast_expression.unary_expression.postfix_expression.primary_expression;
		if(asexp.assignment_expression != null){
			if(idRight.identifier != null && !idRight.identifier.trim().isEmpty()){
				//Validar quando é uma atribuição com outra variavel
				// a = b
				validateActribWithId(idLeft, idRight.identifier);
			}else if(idRight.constant != null){
				//Validar quando é uma atribuição com uma constante
				// a = 3;
				var left_type = variables.get(idLeft);
				checkDeclarationWithConstant(left_type, idRight)
			}else if(idRight.expression != null){
				//Validar quando é uma atribuição com expressão
				// a = b + c
			}				
		}			
		
		var mthodCall = asexp.assignment_expression.conditional_expression.
					logical_or_expression.logical_and_expression.inclusive_or_expression.exclusive_or_expression.
					and_expression.equality_expression.relational_expression.shift_expression.additive_expression.
					multiplicative_expression.cast_expression.unary_expression.postfix_expression.postfix_expression_linha	;
		
	}
	
	def validateAlarg(String tr, String tl){
		if(tl == "int" && tr=="float"){
				error('Tipos incompativeis, De float para int',
					AnsicPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION
				);
			}
			if(tl == "int" && tr=="double"){
				error('Tipos incompativeis, De double para int',
					AnsicPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION
				);
			}
			if(tl == "short" && tr=="float"){
				error('Tipos incompativeis, De float para short',
					AnsicPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION
				);
			}
			if(tl == "short" && tr=="double"){
				error('Tipos incompativeis, De double para short',
					AnsicPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION
				);
			}
			if(tl == "long" && tr=="float"){
				error('Tipos incompativeis, De float para long',
					AnsicPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION
				);
			}
			if(tl == "long" && tr=="double"){
				error('Tipos incompativeis, De double para long',
					AnsicPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION
				);
			}
			if(tl == "int" && tr=="long"){
				error('Tipos incompativeis, De int para long',
					AnsicPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION
				);
			}
			if(tl == "signed" && tr=="unsigned"){
				error('Tipos unsigned, De long para signed',
					AnsicPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION
				);
			}
			if(tl == "unsigned" && tr=="signed"){
				error('Tipos incompativeis, De unsigned para signed',
					AnsicPackage.Literals.ASSIGNMENT_EXPRESSION__UNARY_EXPRESSION
				);
			}	
	}
	
	@Check
	def checkFunctionDefinition(function_definition func_decl){
		//Não tem parametros
		var f = new Function();
		println("Creating function...");
		if(func_decl.declarator.direct_declarator.direct_declarator_linha.direct_declarator_complemento.parameter_type_list == null){
			f.retType = func_decl.declaration_specifiers.get(0).type_specifier.type_name_str;
			f.name = func_decl.declarator.direct_declarator.identifier.toString();
			f.param_number = 0;
			println("Inserting function... " + f.name + "With 0 params");
			functions.put(f.name, f);
		}else{
			f.retType = func_decl.declaration_specifiers.get(0).type_specifier.type_name_str;
			f.name = func_decl.declarator.direct_declarator.identifier.toString();
			var params = func_decl.declarator.direct_declarator.direct_declarator_linha.direct_declarator_complemento.parameter_type_list.parameter_lista.parameter_declarations;
			f.param_number = params.size;		
			for(var i = 0; i< f.param_number; i++){
				var decl = params.get(i);
				f.params_types.add(decl.declaration_specifiers.type_specifier.type_name_str);
			}
			println("Inserting function... " + f.name + "with " + f.param_number + " params");
			functions.put(f.name, f);
			//println( "size:" + func_decl.declarator.direct_declarator.direct_declarator_linha.direct_declarator_complemento.parameter_type_list.parameter_list.get(0));
		}
	}
	@Check
	def checkSwitch(selection_statement sel_stmt){
		var id = sel_stmt.expression.assignment_expression.assignment_expression.conditional_expression.
							logical_or_expression.logical_and_expression.inclusive_or_expression.exclusive_or_expression.
							and_expression.equality_expression.relational_expression.shift_expression.additive_expression.
							multiplicative_expression.cast_expression.unary_expression.postfix_expression.primary_expression.identifier;
		if(variables.keySet.contains(id)){
			error("Variavel não declarada", AnsicPackage.Literals.SELECTION_STATEMENT__EXPRESSION);
		}
		sel_stmt.statement.compound_statement;
	}
	
  
  //
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					AnsicPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
	
}

