/*
 * generated by Xtext 2.9.1
 */
package org.xtext.example.generator

import java.io.PrintWriter
import java.util.Date
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtext.parser.packrat.tokens.AssignmentToken.End
import org.xtext.example.ansic.assignment_expression
import org.xtext.example.ansic.block_item
import org.xtext.example.ansic.function_definition
import org.xtext.example.ansic.selection_statement
import org.xtext.example.ansic.statement
import org.xtext.example.validation.AnsicValidator
import org.xtext.example.validation.AnsicValidator.ExpRetType

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class AnsicGenerator extends AbstractGenerator {

	var out = "";
	var currentLine = 0;
	private var declarations = <String,String>newHashMap();
	private var cases = <String,String>newHashMap();
	private var currentFunc = "";
	private var onFirstCase = true;
	private var caseNumber = 0;
	private var passedSwitch = false;
	private var m_insideSwitch = false;
	private var currentReg = 0;
	private var firstFun = true;
	def getNextLine(){
		currentLine +=8;
		return currentLine+": ";
	}
	def getNextReg(){
		currentReg++;
		return "R"+currentReg;
	}
	def getReg(){
		return "R"+currentReg;
	}
	var calls = 0;
	override void doGenerate(Resource res, IFileSystemAccess2 fsa, IGeneratorContext context) {
		
		for (t : res.allContents.toIterable.filter(typeof(block_item))){
				var current = t.eContainer();
	            checkFunctionChange(current);	            
	            current = t.eContainer();
	            checkSwitchEnd(current)            
				compileBlock(t);
		}
		var ts = new Date().time;
		var keys = declarations.keySet();
		for(var i =0; i< keys.size(); i++){
			out = out.replace(keys.get(i), declarations.get(keys.get(i)));
		}
		var keys2 = cases.keySet();
		for(var i =0; i< keys2.size(); i++){
			out = out.replace(keys2.get(i), cases.get(keys2.get(i)));
		}
		out += "----------------------END----------------------------" + "\n";
		out += "\n";
		println("ENTROOOOOOOOOOOOOOOOOO");
		try {
			var printer = new PrintWriter("/home/axius/runtime-EclipseApplication/teste/"+"outz"+currentLine+".c");
			printer.println(out);
			printer.close();
		} catch (Exception exception) {
			
		}		
		fsa.deleteFile("out" + currentLine+ '.o');
		fsa.generateFile("out" + currentLine+ '.o', out);
		
		out = "";
		currentLine = 0;
		declarations = <String,String>newHashMap();
		cases = <String,String>newHashMap();
		currentFunc = "";
		onFirstCase = true;
		caseNumber = 0;
		passedSwitch = false;
		m_insideSwitch = false;
		currentReg = 0;
	}
	
	def checkSwitchEnd(EObject currentz) {
		var current = currentz;
		while(current != null && !(current instanceof selection_statement)){
            current = current.eContainer();
        }
        var insideSwitch = current instanceof selection_statement;
        //Primeira vez que entrou no switch
        if(passedSwitch){
        	//Se ja passou por algum switch
        	if(m_insideSwitch && !insideSwitch){
        		//Tava dentro do switch (m_insideSwitch) agora nao esotu mais!
        		//Se não tiver nenhum default, volte para ca!!
        		passedSwitch = false;
        		m_insideSwitch = false;
        		if(!cases.containsKey("#DEFAULT")){
        			cases.put("#DEFAULT", (currentLine+8)+"");
        			caseNumber++;
					cases.put("#CASE_"+caseNumber, (currentLine+8)+"");
        		}
        	}
        }
        if(insideSwitch){
        	//out += "BLOCO DE SWITCH \n \n";
        	if(!m_insideSwitch){
        		//Se nao tava dentro de um switch, agora eu to
        		m_insideSwitch = true;
        		passedSwitch = true;
        	}
        }
        if(current instanceof function_definition){
        	var func = current as function_definition;
        	var fName = func.declarator.direct_declarator.identifier.toString();
        	if(!currentFunc.equals(fName)){
        		out += "//" + fName + " code." + "\n";
        		currentFunc = fName;
        		declarations.put("#F_CALL_" +fName, (currentLine+8)+"");
        	}
        }
	}
	
	def checkFunctionChange(EObject currentz) {
		var current = currentz;
		while(current != null && !(current instanceof function_definition)){
            current = current.eContainer();
        }
        if(current instanceof function_definition){
        	var func = current as function_definition;
        	var fName = func.declarator.direct_declarator.identifier.toString();
        	if(!currentFunc.equals(fName)){
        		if(!firstFun){
        			out+= "BR *0(SP) \n";
        		}
        		firstFun = false;
        		out += "//" + fName + " code." + "\n";
        		currentFunc = fName;
        		declarations.put("#F_CALL_" +fName, (currentLine+8)+"");
        	}
        }
	}
	def primaryExpFromAssigExp(assignment_expression exp){
		var ret = exp.conditional_expression.
		logical_or_expression.logical_and_expression.inclusive_or_expression.exclusive_or_expression.
		and_expression.equality_expression.relational_expression.shift_expression.additive_expression.
		multiplicative_expression.cast_expression.unary_expression.postfix_expression.primary_expression;
		return ret;
	}
	def compileBlock(block_item b){
		try {
			if(b.statement != null && b.statement.labeled_statement != null){				
				if(b.statement.labeled_statement.conditional_expression != null){
					//Eh um case!
					if(onFirstCase){
					//Checa se nao goto Next case
					out += getNextLine() + "BEQ " + "#CASE_"+1+  "\n";
					onFirstCase = false;
					}else{
						//Final de outro case
						//Desloque imediatamente para default
						out += getNextLine() + "BR " + "#DEFAULT"+  "\n";
						caseNumber++;
						cases.put("#CASE_"+caseNumber, (currentLine+8)+"");
						//Checa se nao goto Next case
						out += getNextLine() + "BEQ " + "#CASE_"+(caseNumber+1)+ "\n";
						
					}
				}else{
					//Eh um default
					cases.put("#DEFAULT", (currentLine+8)+"");
					caseNumber++;
					cases.put("#CASE_"+caseNumber, (currentLine+8)+"");
				}
				if(b.statement.labeled_statement.statement != null){
					checkForStatement(b.statement.labeled_statement.statement);
				}					
			}
			if(b.statement != null){
				checkForStatement(b.statement)	
			}else if(b.declaration != null){
				checkForDeclaration(b);
			}
			
		} catch (Exception exception) {
			
		}
			
	}
	
	def checkForDeclaration(block_item b) {
		//Tratar quando for uma declaração
		var id = b.declaration.init_declarator_list.get(0).init_declarator.declarator.direct_declarator.identifier;
		generateToAssig(id, b.declaration.init_declarator_list.get(0).init_declarator.initializer.assignment_expression);
	}
	
	def gerarCodigoParaSwitch(selection_statement jump){
		//Gerar codigo para switch aqui...
	}
	
	def checkForStatement(statement s) {
		if(s.selection_statement != null){
			//É um switch
			gerarCodigoParaSwitch(s.selection_statement)
		}
		generateForDecl(s);
	}
	
	def generateToAssig(String id, assignment_expression asexp){
		var rightSide = primaryExpFromAssigExp(asexp);
		if(AnsicValidator.getExpType(asexp) == null){
				
				if(rightSide.constant != null){
				//É uma atribuição com uma contante: x=a;
					if(rightSide.constant.f_constant != null && !rightSide.constant.f_constant.isEmpty()){
						out += getNextLine() +"ST " + id + ", #" + rightSide.constant.f_constant.toString() + "\n";	
					}else if(rightSide.constant.char == null || rightSide.constant.char.isEmpty()){
						out += getNextLine() +"ST " + id + ", #" + rightSide.constant.i_constant.toString() + "\n";
					}				
				}
				if(rightSide.identifier != null && !rightSide.identifier.isEmpty()){
					//É uma atribuição com um ID
					if(declarations.keySet.contains("#F_CALL_"+rightSide.identifier)){
						//É uma chamada a função
						out += getNextLine() + "ADD " + "SP" + ", " + "SP" +", #" + currentFunc+"size"+  "\n";
						out += getNextLine() + "ST " + "*SP" + ", " +  "#" + (currentLine+16) +  "\n";
						out += getNextLine() + "BR " + "#F_CALL_"+rightSide.identifier+  "\n";
						out += getNextLine() + "SUB " + "SP" + ", " + "SP" +", #" + currentFunc+"size"+  "\n";
						out += getNextLine() + "LD " + nextReg + ", " + "SP*" +  "\n";
						out += getNextLine() + "ST " + id + ", " + getReg + "\n";						
					}else{						
						out += getNextLine() + "LD " + nextReg + ", " + rightSide.identifier + "\n";
						out += getNextLine() + "ST " + id + ", "+ getReg + "\n";	
					}				
				}
			}else{
				//Tratar quando é x = x+a ou x=x+2
				var firstOperator = primaryExpFromAssigExp(asexp).identifier
				var secondOperator = asexp.conditional_expression.logical_or_expression.logical_and_expression
				.inclusive_or_expression.exclusive_or_expression.and_expression.equality_expression
				.relational_expression.shift_expression.additive_expression.additive_expression_linha
				.additive_expression_complement.multiplicative_expression.cast_expression.unary_expression
				.postfix_expression.primary_expression
				out += getNextLine() + "LD "+ nextReg +", " + firstOperator  + "\n";
				var storeReg = reg;
				if(secondOperator.identifier == null){
					out += getNextLine()+ "ADD "+ reg +", "+ reg +", #" + secondOperator.constant.i_constant + "\n";	
				}else{
					out += getNextLine() + "LD "+nextReg+", " + secondOperator.identifier + "\n";
					out += getNextLine() + "ADD "+storeReg+", "+storeReg+", "+reg+" \n";
				}
				
				out += getNextLine() + "ST " + id + ", "+storeReg+" \n";
			}
	}
	
	def generateForDecl(statement s) {
		if(s.expression_statement.expression.assignment_expression.unary_expression == null){
			//direct method call?
			var primex = primaryExpFromAssigExp(s.expression_statement.expression.assignment_expression);
			if(primex != null && primex.identifier != null && !primex.identifier.isEmpty){
				if(declarations.keySet.contains("#F_CALL_"+primex.identifier)){
						//É uma chamada a função
						out += getNextLine() + "ADD " + "SP" + ", " + "SP" +", #" + currentFunc+"size"+  "\n";
						out += getNextLine() + "ST " + "*SP" + ", " +  "#" + (currentLine+16) +  "\n";
						out += getNextLine() + "BR " + "#F_CALL_"+primex.identifier+  "\n";
						out += getNextLine() + "SUB " + "SP" + ", " + "SP" +", #" + currentFunc+"size"+  "\n";					
				}
			}
		}
		var prim = s.expression_statement.expression.assignment_expression.unary_expression.postfix_expression.primary_expression
		if(prim.identifier != null && !prim.identifier.isEmpty()){
			
			var id = prim.identifier;
			generateToAssig(id,s.expression_statement.expression.assignment_expression.assignment_expression);			
			//Checar que não tem lado direito, tipo a= b e não pode ser a = b+c
				
		}
	}	
//	def CharSequence compile(block_item item){
//		 item.statement.expression_statement.expression.assignment_expression.compile();
//	}
	
	def static getExpType(assignment_expression exp){
		var current = exp.conditional_expression;
		if(current.conditional_expression_linha != null){
			return ExpRetType.BOOL;
		}
		var current2 = current.logical_or_expression;
		if(current2.logical_or_expression_linha != null){
			return ExpRetType.BOOL;
		}
		var current3 = current2.logical_and_expression;
		if(current3.logical_and_expression_linha != null){
			return ExpRetType.BOOL;
		}
		var current4 = current3.inclusive_or_expression;
		if(current4.inclusive_or_expression_linha != null){
			return ExpRetType.BOOL;
		}
		var current5 = current4.exclusive_or_expression;
		if(current5.exclusive_or_expression_linha != null){
			return ExpRetType.BOOL;
		}
		var current6 = current5.and_expression;
		if(current6.and_expression_linha != null){
			return ExpRetType.BOOL;
		}
		var current7 = current6.equality_expression;
		if(current7.equality_expression_linha != null){
			return ExpRetType.BOOL;
		}
		var current8 = current7.relational_expression;
		if(current8.relational_expression_linha != null){
			return ExpRetType.BOOL;
		}
		var current9 = current8.shift_expression;
		if(current9.shift_expression_linha != null){
			return ExpRetType.NUMERIC;
		}
		var current10 = current9.additive_expression;
		if(current10.additive_expression_linha != null){
			return ExpRetType.NUMERIC;
		}
		var curent11 = current10.multiplicative_expression;
		if(curent11.multiplicative_expression_linha != null){
			return ExpRetType.NUMERIC;
		}
		return null;		
	}
}
